exp(.5)/min(price)
exp(3)/min(price)
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = 2, tau2 = 60, tau3 = 60, tau4 = 60, tau5=70)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
#
# Omega function#
omega_fn 	<- function(k, y){#
	-.8*k*y^2 + 20*y#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= (50 - 10*state[,4]) * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
}
load('~/Desktop/result_5_MDCEV_a1b1.rdata')
# Segment households #
hh_exp$income_group <- factor(hh_exp$income_group, levels=paste("Qt",1:4,sep=""))#
hh_exp$famsize		<- factor(hh_exp$famsize, levels = c("Single","Two", "Three+"))#
hh_exp$income_real	<- factor(hh_exp$income_real)#
panelist	<- data.table(hh_exp)#
setkeyv(panelist, c("household_code","year","month"))#
panelist	<- panelist[,list(first_income = income_group[1], first_famsize = famsize[1]), by=list(household_code)]#
table(panelist$first_income, panelist$first_famsize)#
seg_index	<- 1:(length(levels(panelist$first_income))*length(levels(panelist$first_famsize)))#
names(seg_index) <- paste(rep(levels(panelist$first_income), length(levels(panelist$first_famsize))), #
						  rep(levels(panelist$first_famsize), each=length(levels(panelist$first_income)) ), sep="-")#
tmp			<- paste(panelist$first_income, panelist$first_famsize, sep="-")#
panelist$segment <- seg_index[tmp]#
sel			<- panelist$segment == seg_id#
mydata		<- subset(hh_exp, household_code %in% panelist[sel,household_code])#
ord			<- order(mydata$household_code, mydata$year, mydata$month)#
mydata		<- mydata[ord,]#
mydata$Q	<- mydata$food_quant + mydata$nonedible_quant#
mydata$ymonth <- paste(mydata$year, mydata$month,sep="-")#
#
#####################
# Organize DP data # #
#####################
# -------------------------------------------# #
# Household index and initial stata ##
myidx		<- data.table(mydata)#
myidx		<- myidx[,list(stay = length(month), avg_Q = mean(Q)/my_scale, firstyear = min(year), #
					first_lny = log(dol_purchases[1]), first_Inc = as.numeric(income_group[1]), first_Rc = recession[1]), #
					by=list(household_code)]#
myidx		<- myidx[,id:=1:nrow(myidx)]#
#
hh_index 	<- as.vector(myidx$id)#
TT_vec		<- as.vector(myidx$stay)#
init_state	<- as.matrix(myidx[,list(avg_Q, first_lny, first_Inc, first_Rc)])#
choice_seq	<- as.vector(mydata$basket_type)#
DataState 	<- as.matrix(cbind(I = rep(NA, nrow(mydata)), lny = log(mydata$dol_purchases), #
							Inc = as.numeric(mydata$income_group), Rc=as.numeric(mydata$recession)))#
#
# -------------------------------------------# #
# Model the expenditure process # #
mydata	<- data.table(mydata)#
mydata	<- mydata[, lag_dol_purchases := my_lag(dol_purchases), by = list(household_code)]#
mydata	<- mydata[,':='(ln_dol_purchases = log(dol_purchases), ln_lag_dol_purchases = log(lag_dol_purchases))]#
mydata	<- data.frame(mydata)#
#
sel		<- mydata$recession==1#
fit0	<- plm(ln_dol_purchases ~ ln_lag_dol_purchases + factor(income_group) , data=mydata[!sel,], #
				index = c("household_code","ymonth"), model = "within")#
rho0	<- coef(fit0)["ln_lag_dol_purchases"]#
kappa0	<- mean(mydata[!sel,"ln_dol_purchases"]) * rep(1, length(levels(mydata$income_group)))#
names(kappa0) 	<- paste("factor(income_group)Qt",1:length(levels(mydata$income_group)),sep="")#
sel1 	<- names(coef(fit0)[-1])#
kappa0[sel1]		<- kappa0[sel1] + coef(fit0)[-1]		#
sigma0	<- sum(fit0$residuals^2) / fit0$df.residual#
#
fit1	<- plm(ln_dol_purchases ~ ln_lag_dol_purchases + factor(income_group) , data=mydata[sel,], #
				index = c("household_code","ymonth"), model = "within")#
rho1	<- coef(fit1)["ln_lag_dol_purchases"]#
kappa1	<- mean(mydata[sel,"ln_dol_purchases"]) * rep(1, length(levels(mydata$income_group)))#
names(kappa1) 	<- paste("factor(income_group)Qt",1:length(levels(mydata$income_group)),sep="")#
sel1 	<- names(coef(fit1)[-1])#
kappa1[sel1]		<- kappa1[sel1] + coef(fit1)[-1]	#
sigma1	<- sum(fit1$residuals^2) / fit1$df.residual#
#
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# -------------------------------------------# #
# Model the income transition#
tmp		<- data.table(mydata)#
tmp		<- tmp[, list(income_group = unique(income_group)), by=list(household_code, recession, year)]#
tmp		<- tmp[, income_lag := my_lag(income_group), by=list(household_code)]#
tmp$income_lag <- factor(tmp$income_lag, levels=1:length(levels(mydata$income_group)))#
sel 	<- tmp$recession == 1#
tmp3	<- diag(length(levels(mydata$income_group)))#
tmp1 	<- table(tmp[!sel,income_lag], tmp[!sel,income_group])	#
sel 	<- which(apply(tmp1, 1, function(x) all(x==0)))#
if(length(sel)>0){ tmp1[sel,] <- tmp3[sel,] }#
tmp2 	<- table(tmp[sel,income_lag], tmp[sel,income_group])#
sel 	<- which(apply(tmp2, 1, function(x) all(x==0)))#
if(length(sel)>0){ tmp2[sel,] <- tmp3[sel,] }#
tmp		<- rbind(tmp1/rowSums(tmp1), tmp2/rowSums(tmp2))#
tmp[is.na(tmp)]	<- 0#
Inc_weight <- tmp#
#
# Average price#
tmp		<- data.table(price_dat)#
tmp		<- tmp[,list(price=median(price_paid_norm_index)), by=list(channel_type)]#
price 	<- as.vector(tmp$price)
load('~/Desktop/result_5_MDCEV_a1b1.rdata')
# Segment households #
hh_exp$income_group <- factor(hh_exp$income_group, levels=paste("Qt",1:4,sep=""))#
hh_exp$famsize		<- factor(hh_exp$famsize, levels = c("Single","Two", "Three+"))#
hh_exp$income_real	<- factor(hh_exp$income_real)#
panelist	<- data.table(hh_exp)#
setkeyv(panelist, c("household_code","year","month"))#
panelist	<- panelist[,list(first_income = income_group[1], first_famsize = famsize[1]), by=list(household_code)]#
table(panelist$first_income, panelist$first_famsize)#
seg_index	<- 1:(length(levels(panelist$first_income))*length(levels(panelist$first_famsize)))#
names(seg_index) <- paste(rep(levels(panelist$first_income), length(levels(panelist$first_famsize))), #
						  rep(levels(panelist$first_famsize), each=length(levels(panelist$first_income)) ), sep="-")#
tmp			<- paste(panelist$first_income, panelist$first_famsize, sep="-")#
panelist$segment <- seg_index[tmp]#
sel			<- panelist$segment == seg_id#
mydata		<- subset(hh_exp, household_code %in% panelist[sel,household_code])#
ord			<- order(mydata$household_code, mydata$year, mydata$month)#
mydata		<- mydata[ord,]#
mydata$Q	<- mydata$food_quant + mydata$nonedible_quant#
mydata$ymonth <- paste(mydata$year, mydata$month,sep="-")#
#
#####################
# Organize DP data # #
#####################
# -------------------------------------------# #
# Household index and initial stata ##
myidx		<- data.table(mydata)#
myidx		<- myidx[,list(stay = length(month), avg_Q = mean(Q)/my_scale, firstyear = min(year), #
					first_lny = log(dol_purchases[1]), first_Inc = as.numeric(income_group[1]), first_Rc = recession[1]), #
					by=list(household_code)]#
myidx		<- myidx[,id:=1:nrow(myidx)]#
#
hh_index 	<- as.vector(myidx$id)#
TT_vec		<- as.vector(myidx$stay)#
init_state	<- as.matrix(myidx[,list(avg_Q, first_lny, first_Inc, first_Rc)])#
choice_seq	<- as.vector(mydata$basket_type)#
DataState 	<- as.matrix(cbind(I = rep(NA, nrow(mydata)), lny = log(mydata$dol_purchases), #
							Inc = as.numeric(mydata$income_group), Rc=as.numeric(mydata$recession)))#
#
# -------------------------------------------# #
# Model the expenditure process # #
mydata	<- data.table(mydata)#
mydata	<- mydata[, lag_dol_purchases := my_lag(dol_purchases), by = list(household_code)]#
mydata	<- mydata[,':='(ln_dol_purchases = log(dol_purchases), ln_lag_dol_purchases = log(lag_dol_purchases))]#
mydata	<- data.frame(mydata)#
#
sel		<- mydata$recession==1#
fit0	<- plm(ln_dol_purchases ~ ln_lag_dol_purchases + factor(income_group) , data=mydata[!sel,], #
				index = c("household_code","ymonth"), model = "within")#
rho0	<- coef(fit0)["ln_lag_dol_purchases"]#
kappa0	<- mean(mydata[!sel,"ln_dol_purchases"]) * rep(1, length(levels(mydata$income_group)))#
names(kappa0) 	<- paste("factor(income_group)Qt",1:length(levels(mydata$income_group)),sep="")#
sel1 	<- names(coef(fit0)[-1])#
kappa0[sel1]		<- kappa0[sel1] + coef(fit0)[-1]		#
sigma0	<- sum(fit0$residuals^2) / fit0$df.residual#
#
fit1	<- plm(ln_dol_purchases ~ ln_lag_dol_purchases + factor(income_group) , data=mydata[sel,], #
				index = c("household_code","ymonth"), model = "within")#
rho1	<- coef(fit1)["ln_lag_dol_purchases"]#
kappa1	<- mean(mydata[sel,"ln_dol_purchases"]) * rep(1, length(levels(mydata$income_group)))#
names(kappa1) 	<- paste("factor(income_group)Qt",1:length(levels(mydata$income_group)),sep="")#
sel1 	<- names(coef(fit1)[-1])#
kappa1[sel1]		<- kappa1[sel1] + coef(fit1)[-1]	#
sigma1	<- sum(fit1$residuals^2) / fit1$df.residual#
#
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# -------------------------------------------# #
# Model the income transition#
tmp		<- data.table(mydata)#
tmp		<- tmp[, list(income_group = unique(income_group)), by=list(household_code, recession, year)]#
tmp		<- tmp[, income_lag := my_lag(income_group), by=list(household_code)]#
tmp$income_lag <- factor(tmp$income_lag, levels=1:length(levels(mydata$income_group)))#
sel 	<- tmp$recession == 1#
tmp3	<- diag(length(levels(mydata$income_group)))#
tmp1 	<- table(tmp[!sel,income_lag], tmp[!sel,income_group])	#
sel 	<- which(apply(tmp1, 1, function(x) all(x==0)))#
if(length(sel)>0){ tmp1[sel,] <- tmp3[sel,] }#
tmp2 	<- table(tmp[sel,income_lag], tmp[sel,income_group])#
sel 	<- which(apply(tmp2, 1, function(x) all(x==0)))#
if(length(sel)>0){ tmp2[sel,] <- tmp3[sel,] }#
tmp		<- rbind(tmp1/rowSums(tmp1), tmp2/rowSums(tmp2))#
tmp[is.na(tmp)]	<- 0#
Inc_weight <- tmp#
#
# Average price#
tmp		<- data.table(price_dat)#
tmp		<- tmp[,list(price=median(price_paid_norm_index)), by=list(channel_type)]#
price 	<- as.vector(tmp$price)
library(ggplot2)#
library(reshape2)#
library(scatterplot3d)#
library(maxLik)#
library(Rcpp)#
library(RcppGSL)#
library(glmmML)#
library(plm)#
library(zoo)#
library(data.table)#
library(doParallel)
# Segment households #
hh_exp$income_group <- factor(hh_exp$income_group, levels=paste("Qt",1:4,sep=""))#
hh_exp$famsize		<- factor(hh_exp$famsize, levels = c("Single","Two", "Three+"))#
hh_exp$income_real	<- factor(hh_exp$income_real)#
panelist	<- data.table(hh_exp)#
setkeyv(panelist, c("household_code","year","month"))#
panelist	<- panelist[,list(first_income = income_group[1], first_famsize = famsize[1]), by=list(household_code)]#
table(panelist$first_income, panelist$first_famsize)#
seg_index	<- 1:(length(levels(panelist$first_income))*length(levels(panelist$first_famsize)))#
names(seg_index) <- paste(rep(levels(panelist$first_income), length(levels(panelist$first_famsize))), #
						  rep(levels(panelist$first_famsize), each=length(levels(panelist$first_income)) ), sep="-")#
tmp			<- paste(panelist$first_income, panelist$first_famsize, sep="-")#
panelist$segment <- seg_index[tmp]#
sel			<- panelist$segment == seg_id#
mydata		<- subset(hh_exp, household_code %in% panelist[sel,household_code])#
ord			<- order(mydata$household_code, mydata$year, mydata$month)#
mydata		<- mydata[ord,]#
mydata$Q	<- mydata$food_quant + mydata$nonedible_quant#
mydata$ymonth <- paste(mydata$year, mydata$month,sep="-")#
#
#####################
# Organize DP data # #
#####################
# -------------------------------------------# #
# Household index and initial stata ##
myidx		<- data.table(mydata)#
myidx		<- myidx[,list(stay = length(month), avg_Q = mean(Q)/my_scale, firstyear = min(year), #
					first_lny = log(dol_purchases[1]), first_Inc = as.numeric(income_group[1]), first_Rc = recession[1]), #
					by=list(household_code)]#
myidx		<- myidx[,id:=1:nrow(myidx)]#
#
hh_index 	<- as.vector(myidx$id)#
TT_vec		<- as.vector(myidx$stay)#
init_state	<- as.matrix(myidx[,list(avg_Q, first_lny, first_Inc, first_Rc)])#
choice_seq	<- as.vector(mydata$basket_type)#
DataState 	<- as.matrix(cbind(I = rep(NA, nrow(mydata)), lny = log(mydata$dol_purchases), #
							Inc = as.numeric(mydata$income_group), Rc=as.numeric(mydata$recession)))#
#
# -------------------------------------------# #
# Model the expenditure process # #
mydata	<- data.table(mydata)#
mydata	<- mydata[, lag_dol_purchases := my_lag(dol_purchases), by = list(household_code)]#
mydata	<- mydata[,':='(ln_dol_purchases = log(dol_purchases), ln_lag_dol_purchases = log(lag_dol_purchases))]#
mydata	<- data.frame(mydata)#
#
sel		<- mydata$recession==1#
fit0	<- plm(ln_dol_purchases ~ ln_lag_dol_purchases + factor(income_group) , data=mydata[!sel,], #
				index = c("household_code","ymonth"), model = "within")#
rho0	<- coef(fit0)["ln_lag_dol_purchases"]#
kappa0	<- mean(mydata[!sel,"ln_dol_purchases"]) * rep(1, length(levels(mydata$income_group)))#
names(kappa0) 	<- paste("factor(income_group)Qt",1:length(levels(mydata$income_group)),sep="")#
sel1 	<- names(coef(fit0)[-1])#
kappa0[sel1]		<- kappa0[sel1] + coef(fit0)[-1]		#
sigma0	<- sum(fit0$residuals^2) / fit0$df.residual#
#
fit1	<- plm(ln_dol_purchases ~ ln_lag_dol_purchases + factor(income_group) , data=mydata[sel,], #
				index = c("household_code","ymonth"), model = "within")#
rho1	<- coef(fit1)["ln_lag_dol_purchases"]#
kappa1	<- mean(mydata[sel,"ln_dol_purchases"]) * rep(1, length(levels(mydata$income_group)))#
names(kappa1) 	<- paste("factor(income_group)Qt",1:length(levels(mydata$income_group)),sep="")#
sel1 	<- names(coef(fit1)[-1])#
kappa1[sel1]		<- kappa1[sel1] + coef(fit1)[-1]	#
sigma1	<- sum(fit1$residuals^2) / fit1$df.residual#
#
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# -------------------------------------------# #
# Model the income transition#
tmp		<- data.table(mydata)#
tmp		<- tmp[, list(income_group = unique(income_group)), by=list(household_code, recession, year)]#
tmp		<- tmp[, income_lag := my_lag(income_group), by=list(household_code)]#
tmp$income_lag <- factor(tmp$income_lag, levels=1:length(levels(mydata$income_group)))#
sel 	<- tmp$recession == 1#
tmp3	<- diag(length(levels(mydata$income_group)))#
tmp1 	<- table(tmp[!sel,income_lag], tmp[!sel,income_group])	#
sel 	<- which(apply(tmp1, 1, function(x) all(x==0)))#
if(length(sel)>0){ tmp1[sel,] <- tmp3[sel,] }#
tmp2 	<- table(tmp[sel,income_lag], tmp[sel,income_group])#
sel 	<- which(apply(tmp2, 1, function(x) all(x==0)))#
if(length(sel)>0){ tmp2[sel,] <- tmp3[sel,] }#
tmp		<- rbind(tmp1/rowSums(tmp1), tmp2/rowSums(tmp2))#
tmp[is.na(tmp)]	<- 0#
Inc_weight <- tmp#
#
# Average price#
tmp		<- data.table(price_dat)#
tmp		<- tmp[,list(price=median(price_paid_norm_index)), by=list(channel_type)]#
price 	<- as.vector(tmp$price)
Inc_weight
tmp
y_kernal
load('~/Desktop/result_5_MDCEV_a1b1.rdata')
library(ggplot2)#
library(reshape2)#
library(scatterplot3d)#
library(maxLik)#
library(Rcpp)#
library(RcppGSL)#
library(glmmML)#
library(plm)#
library(zoo)#
library(data.table)#
library(doParallel)
model_name 	<- "MDCEV_a1b1"#
run_id		<- 1#
seg_id		<- 1#
make_plot	<- FALSE#
#
control_list <- list(	value_max_iter 	= 500,#
						tol				= 1e-6,#
						display_freq	= 20,#
						brent_tol		= 0.00001, #
						brent_max_iter 	= 300,#
						inter_spline	= TRUE#
				)#
##############
# Functions ##
##############
matrix_expand <- function(mat, vec){#
	n1	<- nrow(mat)#
	n2	<- length(vec)#
	sel	<- rep(1:n1, n2)#
	mat_new <- cbind(mat[sel,], rep(vec, each=n1))#
	return(mat_new)#
}#
#
my_lag 	<- function(x){#
	return(c(NA, x[-length(x)]))#
}
# Segment households #
hh_exp$income_group <- factor(hh_exp$income_group, levels=paste("Qt",1:4,sep=""))#
hh_exp$famsize		<- factor(hh_exp$famsize, levels = c("Single","Two", "Three+"))#
hh_exp$income_real	<- factor(hh_exp$income_real)#
panelist	<- data.table(hh_exp)#
setkeyv(panelist, c("household_code","year","month"))#
panelist	<- panelist[,list(first_income = income_group[1], first_famsize = famsize[1]), by=list(household_code)]#
table(panelist$first_income, panelist$first_famsize)#
seg_index	<- 1:(length(levels(panelist$first_income))*length(levels(panelist$first_famsize)))#
names(seg_index) <- paste(rep(levels(panelist$first_income), length(levels(panelist$first_famsize))), #
						  rep(levels(panelist$first_famsize), each=length(levels(panelist$first_income)) ), sep="-")#
tmp			<- paste(panelist$first_income, panelist$first_famsize, sep="-")#
panelist$segment <- seg_index[tmp]#
sel			<- panelist$segment == seg_id#
mydata		<- subset(hh_exp, household_code %in% panelist[sel,household_code])#
ord			<- order(mydata$household_code, mydata$year, mydata$month)#
mydata		<- mydata[ord,]#
mydata$Q	<- mydata$food_quant + mydata$nonedible_quant#
mydata$ymonth <- paste(mydata$year, mydata$month,sep="-")#
#
#####################
# Organize DP data # #
#####################
# -------------------------------------------# #
# Household index and initial stata ##
myidx		<- data.table(mydata)#
myidx		<- myidx[,list(stay = length(month), avg_Q = mean(Q)/my_scale, firstyear = min(year), #
					first_lny = log(dol_purchases[1]), first_Inc = as.numeric(income_group[1]), first_Rc = recession[1]), #
					by=list(household_code)]#
myidx		<- myidx[,id:=1:nrow(myidx)]#
#
hh_index 	<- as.vector(myidx$id)#
TT_vec		<- as.vector(myidx$stay)#
init_state	<- as.matrix(myidx[,list(avg_Q, first_lny, first_Inc, first_Rc)])#
choice_seq	<- as.vector(mydata$basket_type)#
DataState 	<- as.matrix(cbind(I = rep(NA, nrow(mydata)), lny = log(mydata$dol_purchases), #
							Inc = as.numeric(mydata$income_group), Rc=as.numeric(mydata$recession)))#
#
# -------------------------------------------# #
# Model the expenditure process # #
mydata	<- data.table(mydata)#
mydata	<- mydata[, lag_dol_purchases := my_lag(dol_purchases), by = list(household_code)]#
mydata	<- mydata[,':='(ln_dol_purchases = log(dol_purchases), ln_lag_dol_purchases = log(lag_dol_purchases))]#
mydata	<- data.frame(mydata)#
#
sel		<- mydata$recession==1#
fit0	<- plm(ln_dol_purchases ~ ln_lag_dol_purchases + factor(income_group) , data=mydata[!sel,], #
				index = c("household_code","ymonth"), model = "within")#
rho0	<- coef(fit0)["ln_lag_dol_purchases"]#
kappa0	<- mean(mydata[!sel,"ln_dol_purchases"]) * rep(1, length(levels(mydata$income_group)))#
names(kappa0) 	<- paste("factor(income_group)Qt",1:length(levels(mydata$income_group)),sep="")#
sel1 	<- names(coef(fit0)[-1])#
kappa0[sel1]		<- kappa0[sel1] + coef(fit0)[-1]		#
sigma0	<- sum(fit0$residuals^2) / fit0$df.residual#
#
fit1	<- plm(ln_dol_purchases ~ ln_lag_dol_purchases + factor(income_group) , data=mydata[sel,], #
				index = c("household_code","ymonth"), model = "within")#
rho1	<- coef(fit1)["ln_lag_dol_purchases"]#
kappa1	<- mean(mydata[sel,"ln_dol_purchases"]) * rep(1, length(levels(mydata$income_group)))#
names(kappa1) 	<- paste("factor(income_group)Qt",1:length(levels(mydata$income_group)),sep="")#
sel1 	<- names(coef(fit1)[-1])#
kappa1[sel1]		<- kappa1[sel1] + coef(fit1)[-1]	#
sigma1	<- sum(fit1$residuals^2) / fit1$df.residual#
#
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# -------------------------------------------# #
# Model the income transition#
tmp		<- data.table(mydata)#
tmp		<- tmp[, list(income_group = unique(income_group)), by=list(household_code, recession, year)]#
tmp		<- tmp[, income_lag := my_lag(income_group), by=list(household_code)]#
tmp$income_lag <- factor(tmp$income_lag, levels=1:length(levels(mydata$income_group)))#
sel 	<- tmp$recession == 1#
tmp3	<- diag(length(levels(mydata$income_group)))#
tmp1 	<- table(tmp[!sel,income_lag], tmp[!sel,income_group])	#
sel 	<- which(apply(tmp1, 1, function(x) all(x==0)))#
if(length(sel)>0){ tmp1[sel,] <- tmp3[sel,] }#
tmp2 	<- table(tmp[sel,income_lag], tmp[sel,income_group])#
sel 	<- which(apply(tmp2, 1, function(x) all(x==0)))#
if(length(sel)>0){ tmp2[sel,] <- tmp3[sel,] }#
tmp		<- rbind(tmp1/rowSums(tmp1), tmp2/rowSums(tmp2))#
tmp[is.na(tmp)]	<- 0#
Inc_weight <- tmp#
#
# Average price#
tmp		<- data.table(price_dat)#
tmp		<- tmp[,list(price=median(price_paid_norm_index)), by=list(channel_type)]#
price 	<- as.vector(tmp$price)
Inc_weigth
Inc_weight
y_kernal
library(ggplot2)#
library(reshape2)#
library(scatterplot3d)#
library(maxLik)#
library(Rcpp)#
library(RcppGSL)#
library(glmmML)#
sourceCpp("~/Documents/Research/Store switching/Exercise/Basket DP/0_DAM_functions.cpp")#
#
control_list <- list(	value_max_iter 	= 500,#
						tol				= 1e-6,#
						display_freq	= 20,#
						brent_tol		= 0.00001, #
						brent_max_iter 	= 300,#
						inter_spline	= TRUE#
				)#
##############
# Functions ##
##############
matrix_expand <- function(mat, vec){#
	n1	<- nrow(mat)#
	n2	<- length(vec)#
	sel	<- rep(1:n1, n2)#
	mat_new <- cbind(mat[sel,], rep(vec, each=n1))#
	return(mat_new)#
}#
#
my_lag 	<- function(x){#
	return(c(NA, x[-length(x)]))#
}
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = 2, tau2 = 60, tau3 = 60, tau4 = 60, tau5=70)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
#
# Omega function#
omega_fn 	<- function(k, y){#
	-.8*k*y^2 + 20*y#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = 2, tau2 = 0, tau3 = 0, tau4 = 0, tau5=0)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
#
# Omega function#
omega_fn 	<- function(k, y){#
	-.8*k*y^2 + 20*y#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC
# Omega function#
omega_fn 	<- function(k, y){#
	-2*k*y^2 + 50*y#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}
# Omega function#
omega_fn 	<- function(k, y){#
	-2*k*y^2 + 100*y#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}
# Omega function#
omega_fn 	<- function(k, y){#
	-2*k*y^2 + 120*y#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}
# Omega function#
omega_fn 	<- function(k, y){#
	-.2*k*y^2 + 12*y#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}
# Omega function#
omega_fn 	<- function(k, y){#
	-.1*k*y^2 + 6*y#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = 2, tau2 = 0, tau3 = 0, tau4 = 0, tau5=0)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
#
# Omega function#
omega_fn 	<- function(k, y){#
	-.1*k*y^2 + 6*y#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
}
# Omega function#
omega_fn 	<- function(k, y){#
# 	-.1*k*y^2 + 6*y#
0#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
}
# Omega function#
omega_fn 	<- function(k, y){#
# 	-.1*k*y^2 + 6*y#
0#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)
tmp
head(ggtmp)
ggtmp
# Omega function#
omega_fn 	<- function(k, y){#
# 	-.1*k*y^2 + 6*y#
rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
}
Inc_weight
param
sourceCpp("~/Documents/Research/Store switching/Exercise/Basket DP/0_DAM_functions.cpp")
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = 3, tau2 = 0, tau3 = 0, tau4 = 0, tau5=0)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
#
# Omega function#
omega_fn 	<- function(k, y){#
# 	-.1*k*y^2 + 6*y#
rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
}
# Omega function#
omega_fn 	<- function(k, y){#
	-.1*k*y^2 + 6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
}
sourceCpp("~/Documents/Research/Store switching/Exercise/Basket DP/0_DAM_functions.cpp")
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
}
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = .5, tau2 = 0, tau3 = 0, tau4 = 0, tau5=0)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
}
library(ggplot2)#
library(reshape2)#
library(scatterplot3d)#
library(maxLik)#
library(Rcpp)#
library(RcppGSL)#
library(glmmML)#
sourceCpp("~/Documents/Research/Store switching/Exercise/Basket DP/0_DAM_functions.cpp")#
#
control_list <- list(	value_max_iter 	= 500,#
						tol				= 1e-6,#
						display_freq	= 20,#
						brent_tol		= 0.00001, #
						brent_max_iter 	= 300,#
						inter_spline	= TRUE#
				)#
##############
# Functions ##
##############
matrix_expand <- function(mat, vec){#
	n1	<- nrow(mat)#
	n2	<- length(vec)#
	sel	<- rep(1:n1, n2)#
	mat_new <- cbind(mat[sel,], rep(vec, each=n1))#
	return(mat_new)#
}#
#
my_lag 	<- function(x){#
	return(c(NA, x[-length(x)]))#
}#
#
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = 3, tau2 = 0, tau3 = 0, tau4 = 0, tau5=0)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
}
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 2.5, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
}
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
}
my_grid
c_grid 	<- seq(.5, 4, by = .2)
c_grid 		<- seq(.5, 4, by = .2)#
	plot_state 	<- 100:105#
	choice_k 	<- 1:2
state	<- DP_list$state#
	V		<- DP_list$value_fn#
	nc		<- length(c_grid)#
	if(is.null(plot_state)) {plot_state <- 1:nrow(state) }#
	if(is.null(choice_k))	{choice_k		<- 1:K }#
	ns		<- length(plot_state)#
	nQ 		<- length(choice_k)
c_star	<- as.matrix(DP_list$policy$c[plot_state,choice_k])#
	dimnames(c_star) <- list(plot_state, Q_grid)#
	vc		<- array(NA, c(ns, nQ, nc+1), #
				dimnames = list(plot_state, choice_k, c(c_grid, "")) )
Q_grid	<- DP_list$Q_grid
c_star	<- as.matrix(DP_list$policy$c[plot_state,choice_k])#
	dimnames(c_star) <- list(plot_state, Q_grid)#
	vc		<- array(NA, c(ns, nQ, nc+1), #
				dimnames = list(plot_state, choice_k, c(c_grid, "")) )
Q_grid
c_star	<- as.matrix(DP_list$policy$c[plot_state,choice_k])#
	dimnames(c_star) <- list(plot_state, Q_grid[choice_k])
vc		<- array(NA, c(ns, nQ, nc+1), #
				dimnames = list(plot_state, choice_k, c(c_grid, "")) )
inter_spline <- control_list$inter_spline#
	x3		<- sort(unique(state[,3]))#
	x4		<- sort(unique(state[,4]))
x3_idx 	<- findInterval1(3, x3)
x3_idx
inter_spline <- control_list$inter_spline#
	x1		<- sort(unique(state[,1]))#
	x2		<- sort(unique(state[,2]))#
	x3		<- sort(unique(state[,3]))#
	x4		<- sort(unique(state[,4]))#
	N1		<- length(x1)#
	N2		<- length(x2)#
	N3		<- length(x3)#
	N4		<- length(x4)#
	# Value function interpolation: cspline or linear#
	spl_list <- lapply(1:(N2*N3*N4), function(i)#
					 splinefun(x = x1, y = V[seq(N1*i-N1+1, N1*i)], method="natural") )
spl_list[[1]](3.2)
str(DP_list)
state	<- DP_list$state#
	V		<- DP_list$value_fn#
	Q_grid	<- DP_list$Q_grid#
	TR_grid	<- DP_list$TR_grid#
	omega_fn<- DP_list$omega#
	K		<- DP_list$K#
	param	<- DP_list$param#
	beta	<- DP_list$beta#
	Inc_weight	<- DP_list$Inc_weight#
	y_kernal	<- DP_list$y_kernal#
	price	<- DP_list$price#
	omega_mat 	<- sapply(1:K, function(x) omega_fn(x, state[,2]))
sol <- Solve_DP_fnC(state, V, omega_mat, K, param, beta, Q_grid, TR_grid, Inc_weight, y_kernal, price, control_list)
str(sol)
sourceCpp("~/Documents/Research/Store switching/Exercise/Basket DP/0_DAM_functions.cpp")
c_grid 		<- seq(.5, 4, by = .2)#
	plot_state 	<- state[100:105,]#
	choice_k 	<- 1#
	ggtmp		<- cal_valuefn(DP_list, c_grid, plot_state, choice_k)
head(ggtmp)
plot_state 	<- 100:105#
	choice_k 	<- 1#
	tmp		<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k)#
	dimnames(tmp) <- list(state_idx = plot_state, c = c_grid)
sourceCpp("~/Documents/Research/Store switching/Exercise/Basket DP/0_DAM_functions.cpp")
dim(DP_list$policy$c)
sourceCpp("~/Documents/Research/Store switching/Exercise/Basket DP/0_DAM_functions.cpp")
c_grid 		<- seq(.5, 4, by = .2)#
	plot_state 	<- 100:105#
	choice_k 	<- 1#
	tmp			<- DP_list$DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp)
str(tmp)
DP_list$DP_list$policy$c[plot_state, choice_k]
tmp			<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp)
str(tmp)
sourceCpp("~/Documents/Research/Store switching/Exercise/Basket DP/0_DAM_functions.cpp")
# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, by = .2)#
	plot_state 	<- 100:105#
	choice_k 	<- 1#
	tmp			<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp)#
	dimnames(tmp) <- list(state_idx = plot_state, c = c(c_grid,""))
ggtmp <- melt(tmp)
head(ggtmp)
sel <- is.na(ggtmp$c)
sum(sel)
tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]
tmp_cstar
# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, by = .2)#
	plot_state 	<- 100:105#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_idx = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]
head(ggtmp)
# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, by = .2)#
	plot_state 	<- 100:105#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]
ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]
unique(ggtmp$Rc)
quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)
ns
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = 3, tau2 = 0, tau3 = 0, tau4 = 0, tau5=0)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, by = .2)#
	plot_state 	<- 100:105#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}
plot_state 	<- 100:105#
	state[plot_state,]
# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]
quartz()#
	print(ggplot(subset(ggtmp, Inc==3), aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)
my_grid
# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, by = .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)
print(ggplot(ggtmp, aes(c, value, col=I)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap( ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)
print(ggplot(ggtmp, aes(c, value, col=factor(I))) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap( ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)
print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)
print(ggplot(ggtmp, aes(c, value, line_type = factor(I))) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap( ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = 3, tau2 = 1, tau3 = 1, tau4 = 1, tau5=1)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, by = .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = 3, tau2 = .5, tau3 = .5, tau4 = .5, tau5=.5)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, by = .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = 3.5, tau2 = .5, tau3 = .5, tau4 = .5, tau5=.5)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, by = .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}
init_state 	<- state[50,]	# Initial state#
TT			<- 300				# The length of simulating time series
init_state 	<- state[50,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data1 <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, y_seq=rep(NA,TT), Q_seq=rep(NA,TT), #
							k_seq=rep(NA, TT),DP_list, control_list)
init_state 	<- state[50,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data1 <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)
str(mydata1)
str(my_data1)
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))
head(ggtmp)
sourceCpp("~/Documents/Research/Store switching/Exercise/Basket DP/0_DAM_functions.cpp")
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))
head(ggtmp)
unique(ggtmp$Rc)
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t")
head(ggtmp1)
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
###################
# Identification # #
###################
tmp 	<- Bellman_operatorC(DP_list, control_list)#
ccp_base<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])
sel_param 	<- "lambda"		# The parameter name that is changed#
delta 		<- -2			# The change value#
param1		<- param#
param1[sel_param] <- param[sel_param] + delta#
DP_list1	<- DP_list #
DP_list1$param <- param1#
DP_list1 	<- value_iteration_fnC(DP_list1, Bellman_operatorC, print_level=1, control_list)#
tmp			<- Bellman_operatorC(DP_list1, control_list)#
ccp1		<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])
# Plot the CCP functions along states given the two sets of parameters#
ggtmp 		<- rbind(data.frame(ccp_base, Parameter = "Baseline"), data.frame(ccp1, Parameter = "Experiment"))#
ggtmp		<- melt(ggtmp, id.var=c("Parameter","I","y"))#
names(ggtmp)<- c("Parameter","I","y","policy","Probability")
head(ggtmp)
ggtmp 		<- rbind(data.frame(ccp_base, Parameter = "Baseline"), data.frame(ccp1, Parameter = "Experiment"))
head(ggtmp)
head(state)
ggtmp		<- melt(ggtmp, id.var=c("Parameter","I","y","Inc","Rc"))
head(ggtmp)
names(ggtmp)<- c("Parameter","I","y","Inc","Rc","policy","Probability")
ggplot(ggtmp, aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_wrap(y + Inc + Rc ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )
ggplot(ggtmp, aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(y + Inc + Rc ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )
plots 		<- lapply(1:2, function(x) {#
	ggplot(subset(ggtmp, Rc==x), aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_wrap(y + Inc ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )#
	} )
plots 		<- lapply(1:2, function(x) {#
	ggplot(subset(ggtmp, Rc==x), aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(y + Inc ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )#
	} )
plots[[1]]
n_Inc
selRc		<- 0#
plots 		<- lapply(1:n_Inc, function(x) {#
	ggplot(subset(ggtmp, Rc == selRc & Inc==x), aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(y  ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )#
	} )
plots[[1]]
do.call(print, plots)
library(gridExtra)
do.call(grid.arrange, plots, list(ncol=2))
do.call(grid.arrange, plots, ncol=2)
?grid.arrange
for(i in 1:n_Inc){#
	quartz()#
	print(ggplot(subset(ggtmp, Rc == selRc & Inc==x), aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(y  ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over Inc=", i, "\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )#
	)#
}
for(i in 1:n_Inc){#
	quartz()#
	print(ggplot(subset(ggtmp, Rc == selRc & Inc==i), aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(y  ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over Inc=", i, "\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )#
	)#
}
# Plot the value function from two sets of parameters. #
ggtmp <- rbind(data.frame(state, V = DP_list$value, Parameter = "Baseline"), #
			   data.frame(state, V = DP_list1$value, Parameter = "Experiment"))
head(ggtmp)
ggplot(subset(ggtmp, Rc==selRc & In== i), aes(I, V, col=Parameter)) + geom_point() + geom_line() + #
		facet_wrap(~y) + #
		labs( title = paste("Value function over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )
ggplot(subset(ggtmp, Rc==selRc & Inc== i), aes(I, V, col=Parameter)) + geom_point() + geom_line() + #
		facet_wrap(~y) + #
		labs( title = paste("Value function over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )
ggplot(subset(ggtmp, Rc==selRc), aes(I, V, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(Inc~y) + #
		labs( title = paste("Value function over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )
selRc		<- 0#
ggplot(subset(ggtmp, Rc==selRc), aes(I, V, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(Inc~y, labeller = "label_both") + #
		labs( title = paste("Value function over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )
library(ggplot2)#
library(reshape2)#
library(scatterplot3d)#
library(maxLik)#
library(Rcpp)#
library(RcppGSL)#
library(glmmML)#
library(gridExtra)#
sourceCpp("~/Documents/Research/Store switching/Exercise/Basket DP/0_DAM_functions.cpp")#
#
control_list <- list(	value_max_iter 	= 500,#
						tol				= 1e-6,#
						display_freq	= 20,#
						brent_tol		= 0.00001, #
						brent_max_iter 	= 300,#
						inter_spline	= TRUE#
				)#
##############
# Functions ##
##############
matrix_expand <- function(mat, vec){#
	n1	<- nrow(mat)#
	n2	<- length(vec)#
	sel	<- rep(1:n1, n2)#
	mat_new <- cbind(mat[sel,], rep(vec, each=n1))#
	return(mat_new)#
}#
#
my_lag 	<- function(x){#
	return(c(NA, x[-length(x)]))#
}#
#
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = 3, tau2 = .5, tau3 = .5, tau4 = .5, tau5=.5)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, b#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[50,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inn_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inn_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}
##################
# Simulate data ##
##################
init_state 	<- state[50,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
y_kernal
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = 1, tau2 = .5, tau3 = .5, tau4 = .5, tau5=.5)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[50,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
my_grid$y
exp(my_grid$y)/min(price)
bskt_typeQ
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = .1, tau2 = .5, tau3 = .5, tau4 = .5, tau5=.5)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[50,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
dim(state)
state[200,]
state[210,]
state[250,]
init_state 	<- state[250,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
state[300,]
state[299,]
state[280,]
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
param
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = 5, tau2 = .5, tau3 = .5, tau4 = .5, tau5=.5)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
param
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = 5, tau2 = .5, tau3 = .5, tau4 = 1, tau5=1)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
, tau2 = .5, tau3 = .5, tau4 = 1, tau5=1)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
library(ggplot2)#
library(reshape2)#
library(scatterplot3d)#
library(maxLik)#
library(Rcpp)#
library(RcppGSL)#
library(glmmML)#
library(gridExtra)#
sourceCpp("~/Documents/Research/Store switching/Exercise/Basket DP/0_DAM_functions.cpp")#
#
control_list <- list(	value_max_iter 	= 500,#
						tol				= 1e-6,#
						display_freq	= 20,#
						brent_tol		= 0.00001, #
						brent_max_iter 	= 300,#
						inter_spline	= TRUE#
				)#
##############
# Functions ##
##############
matrix_expand <- function(mat, vec){#
	n1	<- nrow(mat)#
	n2	<- length(vec)#
	sel	<- rep(1:n1, n2)#
	mat_new <- cbind(mat[sel,], rep(vec, each=n1))#
	return(mat_new)#
}#
#
my_lag 	<- function(x){#
	return(c(NA, x[-length(x)]))#
}#
#
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = 5, tau2 = .5, tau3 = .5, tau4 = 1, tau5=1)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
param
###################
# Identification # #
###################
tmp 	<- Bellman_operatorC(DP_list, control_list)#
ccp_base<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])#
#
sel_param 	<- "tau1"		# The parameter name that is changed#
delta 		<- -4			# The change value#
param1		<- param#
param1[sel_param] <- param[sel_param] + delta#
DP_list1	<- DP_list #
DP_list1$param <- param1#
DP_list1 	<- value_iteration_fnC(DP_list1, Bellman_operatorC, print_level=1, control_list)#
tmp			<- Bellman_operatorC(DP_list1, control_list)#
ccp1		<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])#
#
# Plot the CCP functions along states given the two sets of parameters#
ggtmp 		<- rbind(data.frame(ccp_base, Parameter = "Baseline"), data.frame(ccp1, Parameter = "Experiment"))#
ggtmp		<- melt(ggtmp, id.var=c("Parameter","I","y","Inc","Rc"))#
names(ggtmp)<- c("Parameter","I","y","Inc","Rc","policy","Probability")#
selRc		<- 0#
for(i in 1:n_Inc){#
	quartz()#
	print(ggplot(subset(ggtmp, Rc == selRc & Inc==i), aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(y  ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over Inc=", i, "\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )#
	)#
}
bskt_typeQ
param
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 0, tau1 = .5, tau2 = .5, tau3 = .5, tau4 = 1, tau5=1)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value)) + geom_point() + geom_line() + facet_wrap(~k)	#
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
###################
# Identification # #
###################
tmp 	<- Bellman_operatorC(DP_list, control_list)#
ccp_base<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])#
#
sel_param 	<- "lambda"		# The parameter name that is changed#
delta 		<- -2			# The change value#
param1		<- param#
param1[sel_param] <- param[sel_param] + delta#
DP_list1	<- DP_list #
DP_list1$param <- param1#
DP_list1 	<- value_iteration_fnC(DP_list1, Bellman_operatorC, print_level=1, control_list)#
tmp			<- Bellman_operatorC(DP_list1, control_list)#
ccp1		<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])#
#
# Plot the CCP functions along states given the two sets of parameters#
ggtmp 		<- rbind(data.frame(ccp_base, Parameter = "Baseline"), data.frame(ccp1, Parameter = "Experiment"))#
ggtmp		<- melt(ggtmp, id.var=c("Parameter","I","y","Inc","Rc"))#
names(ggtmp)<- c("Parameter","I","y","Inc","Rc","policy","Probability")#
selRc		<- 0#
for(i in 1:n_Inc){#
	quartz()#
	print(ggplot(subset(ggtmp, Rc == selRc & Inc==i), aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(y  ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over Inc=", i, "\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )#
	)#
}#
# Plot the value function from two sets of parameters. #
ggtmp <- rbind(data.frame(state, V = DP_list$value, Parameter = "Baseline"), #
			   data.frame(state, V = DP_list1$value, Parameter = "Experiment"))#
selRc		<- 0#
quartz()#
ggplot(subset(ggtmp, Rc==selRc), aes(I, V, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(Inc~y, labeller = "label_both") + #
		labs( title = paste("Value function over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )
sel_param 	<- "lambda"		# The parameter name that is changed#
delta 		<- -4			# The change value#
param1		<- param#
param1[sel_param] <- param[sel_param] + delta#
DP_list1	<- DP_list #
DP_list1$param <- param1#
DP_list1 	<- value_iteration_fnC(DP_list1, Bellman_operatorC, print_level=1, control_list)#
tmp			<- Bellman_operatorC(DP_list1, control_list)#
ccp1		<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])#
#
# Plot the CCP functions along states given the two sets of parameters#
ggtmp 		<- rbind(data.frame(ccp_base, Parameter = "Baseline"), data.frame(ccp1, Parameter = "Experiment"))#
ggtmp		<- melt(ggtmp, id.var=c("Parameter","I","y","Inc","Rc"))#
names(ggtmp)<- c("Parameter","I","y","Inc","Rc","policy","Probability")#
selRc		<- 0#
for(i in 1:n_Inc){#
	quartz()#
	print(ggplot(subset(ggtmp, Rc == selRc & Inc==i), aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(y  ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over Inc=", i, "\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )#
	)#
}#
# Plot the value function from two sets of parameters. #
ggtmp <- rbind(data.frame(state, V = DP_list$value, Parameter = "Baseline"), #
			   data.frame(state, V = DP_list1$value, Parameter = "Experiment"))#
selRc		<- 0#
quartz()#
ggplot(subset(ggtmp, Rc==selRc), aes(I, V, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(Inc~y, labeller = "label_both") + #
		labs( title = paste("Value function over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )
bskt_typeQ
sel_param 	<- "tau3"		# The parameter name that is changed#
delta 		<- 1.5			# The change value#
param1		<- param#
param1[sel_param] <- param[sel_param] + delta#
DP_list1	<- DP_list #
DP_list1$param <- param1#
DP_list1 	<- value_iteration_fnC(DP_list1, Bellman_operatorC, print_level=1, control_list)#
tmp			<- Bellman_operatorC(DP_list1, control_list)#
ccp1		<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])#
#
# Plot the CCP functions along states given the two sets of parameters#
ggtmp 		<- rbind(data.frame(ccp_base, Parameter = "Baseline"), data.frame(ccp1, Parameter = "Experiment"))#
ggtmp		<- melt(ggtmp, id.var=c("Parameter","I","y","Inc","Rc"))#
names(ggtmp)<- c("Parameter","I","y","Inc","Rc","policy","Probability")#
selRc		<- 0#
for(i in 1:n_Inc){#
	quartz()#
	print(ggplot(subset(ggtmp, Rc == selRc & Inc==i), aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(y  ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over Inc=", i, "\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )#
	)#
}#
# Plot the value function from two sets of parameters. #
ggtmp <- rbind(data.frame(state, V = DP_list$value, Parameter = "Baseline"), #
			   data.frame(state, V = DP_list1$value, Parameter = "Experiment"))#
selRc		<- 0#
quartz()#
ggplot(subset(ggtmp, Rc==selRc), aes(I, V, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(Inc~y, labeller = "label_both") + #
		labs( title = paste("Value function over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 5, tau_b = 0, tau1 = .5, tau2 = .5, tau3 = 2, tau4 = 1, tau5=2)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
param
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 5, tau_b = 2, tau1 = .5, tau2 = .5, tau3 = 2, tau4 = 1, tau5=2)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
param
###################
# Identification # #
###################
tmp 	<- Bellman_operatorC(DP_list, control_list)#
ccp_base<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])#
#
sel_param 	<- "taub1"		# The parameter name that is changed#
delta 		<- -.4			# The change value#
param1		<- param#
param1[sel_param] <- param[sel_param] + delta#
DP_list1	<- DP_list #
DP_list1$param <- param1#
DP_list1 	<- value_iteration_fnC(DP_list1, Bellman_operatorC, print_level=1, control_list)#
tmp			<- Bellman_operatorC(DP_list1, control_list)#
ccp1		<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])#
#
# Plot the CCP functions along states given the two sets of parameters#
ggtmp 		<- rbind(data.frame(ccp_base, Parameter = "Baseline"), data.frame(ccp1, Parameter = "Experiment"))#
ggtmp		<- melt(ggtmp, id.var=c("Parameter","I","y","Inc","Rc"))#
names(ggtmp)<- c("Parameter","I","y","Inc","Rc","policy","Probability")#
selRc		<- 0#
for(i in 1:n_Inc){#
	quartz()#
	print(ggplot(subset(ggtmp, Rc == selRc & Inc==i), aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(y  ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over Inc=", i, "\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )#
	)#
}#
# Plot the value function from two sets of parameters. #
ggtmp <- rbind(data.frame(state, V = DP_list$value, Parameter = "Baseline"), #
			   data.frame(state, V = DP_list1$value, Parameter = "Experiment"))#
selRc		<- 0#
quartz()#
ggplot(subset(ggtmp, Rc==selRc), aes(I, V, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(Inc~y, labeller = "label_both") + #
		labs( title = paste("Value function over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )
###################
# Identification # #
###################
tmp 	<- Bellman_operatorC(DP_list, control_list)#
ccp_base<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])#
#
sel_param 	<- "tau1"		# The parameter name that is changed#
delta 		<- -.4			# The change value#
param1		<- param#
param1[sel_param] <- param[sel_param] + delta#
DP_list1	<- DP_list #
DP_list1$param <- param1#
DP_list1 	<- value_iteration_fnC(DP_list1, Bellman_operatorC, print_level=1, control_list)#
tmp			<- Bellman_operatorC(DP_list1, control_list)#
ccp1		<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])#
#
# Plot the CCP functions along states given the two sets of parameters#
ggtmp 		<- rbind(data.frame(ccp_base, Parameter = "Baseline"), data.frame(ccp1, Parameter = "Experiment"))#
ggtmp		<- melt(ggtmp, id.var=c("Parameter","I","y","Inc","Rc"))#
names(ggtmp)<- c("Parameter","I","y","Inc","Rc","policy","Probability")#
selRc		<- 0#
for(i in 1:n_Inc){#
	quartz()#
	print(ggplot(subset(ggtmp, Rc == selRc & Inc==i), aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(y  ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over Inc=", i, "\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )#
	)#
}#
# Plot the value function from two sets of parameters. #
ggtmp <- rbind(data.frame(state, V = DP_list$value, Parameter = "Baseline"), #
			   data.frame(state, V = DP_list1$value, Parameter = "Experiment"))#
selRc		<- 0#
quartz()#
ggplot(subset(ggtmp, Rc==selRc), aes(I, V, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(Inc~y, labeller = "label_both") + #
		labs( title = paste("Value function over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )
bskt_tyeTR
bskt_tye
bskt_type
bskt_typeQ
bskt_typeTR
param
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 5, tau_b = 3, tau1 = 1, tau2 = .5, tau3 = 2, tau4 = 1, tau5=2)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(200, 250, 300)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
param
exp(4.5)
exp(4.5)/min(price)
bskt_typeQ
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 5, tau_b = 3, tau1 = 2, tau2 = .5, tau3 = 2, tau4 = .5, tau5=2)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(250, 300, 350)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .2#
sigma1 		<- .25#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
y_kernal
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .5#
sigma1 		<- .75#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 3, tau_b = 3, tau1 = 2, tau2 = .5, tau3 = 2, tau4 = .5, tau5=2)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(250, 300, 350)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
init_stae
init_state
exp(4.5)/min(price)
exp(my_grid$I)/min(price)
bskt_typeQ
.4*min(price)
log(.4*min(price))
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 3, tau1 = 0, tau2 = .5, tau3 = 2, tau4 = .5, tau5=2)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(250, 300, 350)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
Inc_weight
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 3, tau1 = 0, tau2 = 0, tau3 = 0, tau4 = 0, tau5=0)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(250, 300, 350)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	-.01*k*y^2 + .6*y#
# rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
###################
# Identification # #
###################
tmp 	<- Bellman_operatorC(DP_list, control_list)#
ccp_base<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])#
#
sel_param 	<- "tau5"		# The parameter name that is changed#
delta 		<- 3			# The change value#
param1		<- param#
param1[sel_param] <- param[sel_param] + delta#
DP_list1	<- DP_list #
DP_list1$param <- param1#
DP_list1 	<- value_iteration_fnC(DP_list1, Bellman_operatorC, print_level=1, control_list)#
tmp			<- Bellman_operatorC(DP_list1, control_list)#
ccp1		<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])#
#
# Plot the CCP functions along states given the two sets of parameters#
ggtmp 		<- rbind(data.frame(ccp_base, Parameter = "Baseline"), data.frame(ccp1, Parameter = "Experiment"))#
ggtmp		<- melt(ggtmp, id.var=c("Parameter","I","y","Inc","Rc"))#
names(ggtmp)<- c("Parameter","I","y","Inc","Rc","policy","Probability")#
selRc		<- 0#
for(i in 1:n_Inc){#
	quartz()#
	print(ggplot(subset(ggtmp, Rc == selRc & Inc==i), aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(y  ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over Inc=", i, "\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )#
	)#
}#
# Plot the value function from two sets of parameters. #
ggtmp <- rbind(data.frame(state, V = DP_list$value, Parameter = "Baseline"), #
			   data.frame(state, V = DP_list1$value, Parameter = "Experiment"))#
selRc		<- 0#
quartz()#
ggplot(subset(ggtmp, Rc==selRc), aes(I, V, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(Inc~y, labeller = "label_both") + #
		labs( title = paste("Value function over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )
selRc <- 1
ggplot(subset(ggtmp, Rc==selRc), aes(I, V, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(Inc~y, labeller = "label_both") + #
		labs( title = paste("Value function over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )
sel_param 	<- "tau2"		# The parameter name that is changed#
delta 		<- 3			# The change value#
param1		<- param#
param1[sel_param] <- param[sel_param] + delta#
DP_list1	<- DP_list #
DP_list1$param <- param1#
DP_list1 	<- value_iteration_fnC(DP_list1, Bellman_operatorC, print_level=1, control_list)#
tmp			<- Bellman_operatorC(DP_list1, control_list)#
ccp1		<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])#
#
# Plot the CCP functions along states given the two sets of parameters#
ggtmp 		<- rbind(data.frame(ccp_base, Parameter = "Baseline"), data.frame(ccp1, Parameter = "Experiment"))#
ggtmp		<- melt(ggtmp, id.var=c("Parameter","I","y","Inc","Rc"))#
names(ggtmp)<- c("Parameter","I","y","Inc","Rc","policy","Probability")#
selRc		<- 0#
for(i in 1:n_Inc){#
	quartz()#
	print(ggplot(subset(ggtmp, Rc == selRc & Inc==i), aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(y  ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over Inc=", i, "\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )#
	)#
}#
# Plot the value function from two sets of parameters. #
ggtmp <- rbind(data.frame(state, V = DP_list$value, Parameter = "Baseline"), #
			   data.frame(state, V = DP_list1$value, Parameter = "Experiment"))#
selRc		<- 0#
quartz()#
ggplot(subset(ggtmp, Rc==selRc), aes(I, V, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(Inc~y, labeller = "label_both") + #
		labs( title = paste("Value function over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 6, tau_b = 3, tau1 = 2, tau2 = 0, tau3 = 0, tau4 = 0, tau5=0)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(250, 300, 350)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
# 	-.01*k*y^2 + .6*y#
rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
param
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 3, tau_b = 3, tau1 = 2, tau2 = 0, tau3 = 0, tau4 = 0, tau5=0)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(250, 300, 350)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
# 	-.01*k*y^2 + .6*y#
rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 3, tau_b = 3, tau1 = 5, tau2 = 0, tau3 = 0, tau4 = 0, tau5=0)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(250, 300, 350)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .1#
sigma1 		<- .15#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
# 	-.01*k*y^2 + .6*y#
rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 3, tau_b = 3, tau1 = 5, tau2 = 0, tau3 = 0, tau4 = 0, tau5=0)#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(.4, 1, .4, 1)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(250, 300, 350)#
n_Inc		<- 4#
make_plot	<- TRUE#
#
# Initiate states#
my_grid <- list(I = c(.5, 1.5, 2, 3, 3.5, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .05#
rho1		<- .07#
sigma0 		<- .5#
sigma1 		<- .75#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
# 	-.01*k*y^2 + .6*y#
rep(0, length(y))#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
Inc_weight
param
bskt_typeQ <- bskt_typeQ/2
price <- price *2
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 100:105#
	state[plot_state,]#
	choice_k 	<- 1#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}#
#
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- bskt_typeQ[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
library(ggplot2)#
library(reshape2)#
library(scatterplot3d)#
library(maxLik)#
library(Rcpp)#
library(RcppGSL)#
library(glmmML)#
#
setwd("~/Documents/Research/Store switching/Exercise/Basket DP/Dynamic allocation simulation")#
source("DAM_2_functions.R")#
source("value_function_iteration.R")#
sourceCpp("DAM_2_functions.cpp")
###################
# Set parameters # #
###################
control_list <- list(	value_max_iter 	= 500,#
						tol				= 1e-6,#
						display_freq	= 20,#
						brent_tol		= 0.00001, #
						brent_max_iter 	= 300,#
						inter_spline	= TRUE#
				)#
#
K <- 4					# Number of basket types#
S <- 3					# Number of retailers#
Sa <- S+2#
alpha <- c(	-1, -2, -1)#
alpha_a <- c(-2, -2) 	# Normalization of the parameters for the outside options#
qz_cons <- 0			# The constant parameter in the utility of quantity outside good.#
gamma <- c(1,1,1)#
param <- c(lambda = 3, tau1=1, tau2=0)					#
beta <- .9#
#
step	<- .5				#
I_grid	<- seq(0,5,by=step)#
c_grid	<- seq(0,8,by=step)#
Q_grid	<- c(0,.5,1.2,2)/2		# Q have K levels #
price	<- c(2,3,2)*2				# Price #
nQ		<- K#
#
gh_num_nodes <- 6#
y_weight<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes <- ghq(gh_num_nodes, modified = F)$zeros#
ymu		<- .2#
ysigma 	<- .2#
y_kernal <- list(nodes = y_nodes, weight = y_weight, mu=ymu, sigma = ysigma, rho = .7)#
y_grid 	<- seq(1, 5, length = 10)#
#
# Simulate a sequence of income to check the coverage of y_grid#
tmp 	<- rep(NA, 500)#
tmp[1]  <- 1#
for(i in 2:length(tmp)){ tmp[i] <- exp(rnorm(1, ymu + y_kernal$rho*log(tmp[(i-1)]), ysigma))}#
plot(1:500, tmp)#
range(tmp)#
#
state	<- cbind(I=rep(I_grid,length(y_grid)),y=rep(y_grid,each=length(I_grid)))	# state matrix#
s_idx	<- cbind(I=rep(1:length(I_grid),length(y_grid)), y=rep(1:length(y_grid),each=length(I_grid)))#
ns		<- nrow(state)#
I_idx	<- 1#
y_idx	<- 2#
#
# Simulate inclusive value #
set.seed(99)#
numsim 		<- 50#
eps_draw	<- matrix(rnorm(numsim*S), numsim, S)#
psi_draw 	<- exp(rep(1,numsim)%*%t(alpha) + eps_draw)#
psi_ext 	<- cbind(psi_draw, rep(1, numsim) %*% t(exp(alpha_a)))#
gamma_ext	<- c(gamma, 1, 1)#
#
# Add more y values to y_grid when computing the inclusive value#
tmp_y_grid 	<- y_grid#
tmp_ny 		<- length(tmp_y_grid)#
#
omega_draw	<- array(NA, c(numsim, tmp_ny, K))#
e_draw 		<- array(NA, c(numsim, tmp_ny, K, Sa))#
my.silent 	<- TRUE#
for(i in 1:numsim){#
	for(j in 1:tmp_ny){#
		for(l in 1:K){#
			sol <- Allocation_fn(y=tmp_y_grid[j],Q=Q_grid[l],psi=psi_ext[i,], gamma=gamma_ext,#
								price=price,S=S, Sa, silent = my.silent)#
			omega_draw[i,j,l] <- sol$max#
			e_draw[i,j,l,] <- sol$e#
		}#
	}#
	print(i)#
}#
sum(is.na(omega_draw))/length(omega_draw)#
omega <- apply(omega_draw, c(2,3), mean, na.rm=T)#
dimnames(omega) <- list(tmp_y_grid, 1:K)#
#
# Spline interpolation of omega function along y#
omega_list <- lapply(1:K, function(i) splinefun(x=tmp_y_grid, y=omega[,i], method="natural"))#
omega_fn <- function(k, y){#
	f  <- omega_list[[k]](y)#
	return(f)#
}#
#
# Plot the omega function along y#
tmp <- seq(min(y_grid), max(y_grid), length=200)#
ggtmp <- matrix(NA, length(tmp), K, dimnames = list(tmp, 1:K))#
for(i in 1:K){#
	ggtmp[,i] <- omega_fn(i, tmp)#
}#
ggtmp 	<- cbind(melt(ggtmp), pnt = "interp")#
ggtmp1 	<- cbind(melt(omega), pnt = "knots")#
ggtmp 	<- rbind(ggtmp, ggtmp1)#
names(ggtmp) <- c("y","k", "omega","pnt")#
ggtmp$k <- factor(ggtmp$k)#
ggplot(ggtmp, aes(y, omega, col=k)) + geom_line() +#
		geom_point(data = subset(ggtmp, pnt == "knots")) + #
# 		facet_wrap(~k) + #
		labs(title = expression(paste("Cubic spline interpolation of the inclusive value ", omega, "(k,y)"), sep="") ) #
#
#####################
# Dynamic solution ##
#####################
tmp		<- floor(quantile(1:ns, c(1:K)/K))#
tmp		<- c(tmp[1], diff(tmp))#
policy_k<- rev(unlist(lapply(1:K,function(i) rep(i,tmp[i])) ))#
#
DP_list	<- list(state 		= as.matrix(state), K = K,#
				value_fn 	= 0.5*log(state[,I_idx]+1) ,#
# 				value_fn	= sapply(1:ns, function(i) uflow_fn(c=state[i,1]/2, I=state[i,1], Q=0, y=state[i,2], sel_k=1, omega=omega_fn, param))/(1-beta),#
				policy	 	= list(k = policy_k,c = state[,I_idx] %*% t(rep(1,nQ))),#
				K			= K,#
				param		= param,#
				beta		= beta,#
				state_idx 	= s_idx,#
				status 		= 1, #
				Q_grid		= Q_grid,#
				y_kernal	= y_kernal,#
				omega		= omega_fn,#
				price 		= price,#
				Iteration 	= 0 )#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
# solR <- value_iteration_fnC(DP_list, Bellman_operator, print_level=1, control_list)#
# #
# # Check if c++ function and R functions return the same results;#
# plot(solC$value_fn, solR$value_fn); abline(a = 0, b= 1, col="red")#
#
# Plot value function #
scatterplot3d(DP_list$state[,I_idx], DP_list$state[,y_idx], DP_list$value_fn, xlab = "I", ylab="y", zlab="value", #
			main="Value funciton", angle = 60)#
#
# 2D value function along I#
sel <- unique(floor(length(y_grid)*c(.1, .2, .3, .5, .6,.7,1)))#
sel <- y_grid[sel]#
ggtmp <- data.frame(state, v=DP_list$value_fn)#
quartz()#
ggplot(subset(ggtmp, y %in% sel), aes(I, v) ) + geom_point() + geom_line() + #
		facet_wrap(~ y) + #
		labs(title = "Value function in I\n facet by y")#
#
# Plot policy function ccp#
tmp <- Bellman_operatorC(DP_list, control_list)#
tmp1 <- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3],k4=tmp$ccp[,4])#
ggtmp <- melt(tmp1, id.var=c("I","y"))#
names(ggtmp)[3] <- "policy"#
quartz()#
ggplot(subset(ggtmp, y %in% sel), aes(I, value)) + geom_point() + geom_line() + #
		facet_grid(y ~ policy, labeller = "label_both") + #
		labs(y="Probability", title = "Policy function k(CCP) " )#
#
# Plot policy function c#
tmp 			<- DP_list$policy$c#
dimnames(tmp) 	<- list(1:ns, Q_grid)#
ggtmp 			<- melt(tmp)#
names(ggtmp) 	<- c("state_index","Q","c")#
ggtmp$I			<- state[ggtmp$state_index, I_idx]#
ggtmp$y			<- state[ggtmp$state_index, y_idx]#
#
quartz()#
print(ggplot(subset(ggtmp, y %in% sel), aes(I, c)) + geom_point() + geom_line() + #
		facet_grid(Q ~ y, labeller = "label_both") + #
		geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
		labs(title = paste("Policy function c at y grid",sep=""))#
)
##################
# Simulate data ##
##################
init_state <- state[30,]	# Initial state#
TT		<- 200				# The length of simulating time series#
#
# No randomness in the consumption function #
my_data1 <- simulate_seq_fnC(init_state, TT, draw_all=TRUE, y_seq=rep(NA,TT), Q_seq=rep(NA,TT), #
							k_seq=rep(NA, TT),DP_list, control_list)    #
my_data <- simulate_seq_fn(init_state, TT, draw_all = TRUE, y_seq=NULL, Q_seq=NULL, k_seq=NULL, DP_list, control_list, #
							alpha, alpha_a, gamma)#
#
# Plot the simulation#
ggtmp <- my_data[[1]]#
ggtmp$Q <- Q_grid[ggtmp$k]#
ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","y","k","c_inventory")]), id="t") #
quartz()#
ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
		facet_grid(variable ~ ., scales="free_y") + #
		labs(title = "Simulated sequence")
price
Q_grid
summary(state)
