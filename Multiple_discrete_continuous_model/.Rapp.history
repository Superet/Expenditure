par(mfrow = c(5, 3))#
for(i in 1:13){#
	acf(tmp[,1,i])#
}
tmp <- extract(sim, "mu", permuted = F)
dim(tmp)
par(mfrow = c(2, 3))#
for(i in 1:6){#
	acf(tmp[,1,i])#
}
tmp <- extract(sim, "tau", permuted = F)
par(mfrow = c(2, 3))#
for(i in 1:6){#
	acf(tmp[,1,i])#
}
save_par
tmp <- extract(sim, "gamma", permuted = F)
par(mfrow = c(2, 3))#
for(i in 1:6){#
	acf(tmp[,1,i])#
}
tmp <- extract(sim, "gamma", permuted = F)
dim(tmp)
par(mfrow = c(2, 3))#
for(i in 1:6){#
	acf(tmp[,1,i])#
}
numchain	<- 4#
numiter		<- 750#
numburn		<- 250#
numthin		<- 2
(numiter - numburn)/numthin
# Set stan simulation parameters #
numchain	<- 4#
numiter		<- 1250#
numburn		<- 250#
numthin		<- 4
(numiter - numburn)/numthin
?stan
library(rstan)
?stan
# Set stan simulation parameters #
numchain	<- 4#
numiter		<- 2000#
numburn		<- 1000#
numthin		<- 4
(numiter - numburn)/numthin
load("/Users/chaoqunchen/Desktop/MDCEV_stan_cpi_seg1_sub2_chain4_iter500_burn250_thin1.rdata")
str(fmt_attr)
length(unique(fmt_attr$scantrack_market_descr))
load("/Users/chaoqunchen/Desktop/MDCEV_stan_cpi_seg2_sub20_chain4_iter2500_burn1250_thin5.rdata")
library(rstan)
plot(sim)
colMeans(extract(sim)$beta)
colMeans(extract(sim)$mu)
colMeans(extract(sim)$tau)
fmt_name
shr.par
colMeans(extract(sim)$gamma)
colMeans(extract(sim)$sigma)
mean(extract(sim)$sigma)
exp(-.36)
25*25
4.25/(75.5*.9)
matrix(c(1, rho, rho, 1), 2,2)
n 	<- 10#
T	<- 20#
rho <- -.4#
ab	<- mvrnorm(n, rep(0, 0), matrix(c(1, rho, rho, 1), 2,2))
library(MASS)
ab	<- mvrnorm(n, rep(0, 0), matrix(c(1, rho, rho, 1), 2,2))
library(mvtnorm)
ab	<- rmvnorm(n, rep(0, 0), matrix(c(1, rho, rho, 1), 2,2))
library(mvtnorm)
matrix(c(1, rho, rho, 1), 2,2)
ab	<- rmvnorm(n, rep(0, 0), matrix(c(1, rho, rho, 1), 2,2))
ab	<- rmvnorm(n, rep(0, 2), matrix(c(1, rho, rho, 1), 2,2))
ab
ab	<- rmvnorm(n, rep(1, 2), matrix(c(1, rho, rho, 1), 2,2))
y 	<- lapply(1:n, function(i) ab[i,1] + ab[i,2]*x + rnorm(T))
x 	<- 1:T#
y 	<- lapply(1:n, function(i) ab[i,1] + ab[i,2]*x + rnorm(T))
y
y 	<- sapply(1:n, function(i) ab[i,1] + ab[i,2]*x + rnorm(T))
length(y)
mydata <- data.frame(id = rep(1:n, each = T), t = rep(1:T, n), x = x, y = y)
head(mydata)
library(reshape2)#
library(ggplot2)
y 	<- lapply(1:n, function(i) ab[i,1] + ab[i,2]*x + rnorm(T))#
mydata <- melt(y)
haead(mydata)
head(mydata)
mydata <- data.frame(id = mydata$L1, t = rep(1:T, n), x = x, y = mydata$value)
head(mydata)
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id))
y 	<- lapply(1:n, function(i) ab[i,1] + ab[i,2]*x + 0)#
mydata <- melt(y)#
mydata <- data.frame(id = mydata$L1, t = rep(1:T, n), x = x, y = mydata$value)#
#
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id))
ab[,2] <- ab[,2] * .1#
x 	<- 1:T#
y 	<- lapply(1:n, function(i) ab[i,1] + ab[i,2]*x + 0)#
mydata <- melt(y)#
mydata <- data.frame(id = mydata$L1, t = rep(1:T, n), x = x, y = mydata$value)#
#
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id))
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id)) + #
	geom_smooth(method = "lm")
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id), size = .25) + #
	geom_smooth(method = "lm")
library(data.table)
mydata	<- data.table(mydata)
mydata	<- mydata[,within:= c(0, y[-1] - y[-length(y)]), by = list(id)]
head(mydata)
mydata	<- mydata[,within:=within + mean(y[t==1])]
head(mydata)
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id), size = .25) + #
	geom_smooth(method = "lm") + #
	geom_smooth(aes(x, within), method = "lm", color = "red")
n 	<- 10#
T	<- 20#
rho <- .4#
ab	<- rmvnorm(n, rep(0, 2), matrix(c(1, rho, rho, 1), 2,2))#
ab[,2] <- ab[,2] * .1#
x 	<- 1:T#
y 	<- lapply(1:n, function(i) ab[i,1] + ab[i,2]*x + 0)#
mydata <- melt(y)#
mydata <- data.frame(id = mydata$L1, t = rep(1:T, n), x = x, y = mydata$value)#
mydata	<- data.table(mydata)#
mydata	<- mydata[,within:= c(0, y[-1] - y[-length(y)]), by = list(id)]#
mydata	<- mydata[,within:=within + mean(y[t==1])]#
#
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id), size = .25) + #
	geom_smooth(method = "lm") + #
	geom_smooth(aes(x, within), method = "lm", color = "red")
library(mvtnorm)#
library(reshape2)#
library(ggplot2)#
library(data.table)#
#
set.seed(6)#
n 	<- 10#
T	<- 20#
rho <- -.4#
ab	<- rmvnorm(n, rep(0, 2), matrix(c(1, rho, rho, 1), 2,2))#
ab[,2] <- ab[,2] * .1#
x 	<- 1:T#
y 	<- lapply(1:n, function(i) ab[i,1] + ab[i,2]*x + 0)#
mydata <- melt(y)#
mydata <- data.frame(id = mydata$L1, t = rep(1:T, n), x = x, y = mydata$value)#
mydata	<- data.table(mydata)#
mydata	<- mydata[,within:= c(0, y[-1] - y[-length(y)]), by = list(id)]#
mydata	<- mydata[,within:=within + mean(y[t==1])]#
#
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id), size = .25) + #
	geom_smooth(method = "lm") + #
	geom_smooth(aes(x, within), method = "lm", color = "red")
n 	<- 10#
T	<- 20#
rho <- -.4#
ab	<- rmvnorm(n, rep(0, 2), matrix(c(1, rho, rho, 1), 2,2))#
ab[,2] <- ab[,2] * .1#
x 	<- 1:T#
y 	<- lapply(1:n, function(i) ab[i,1] + ab[i,2]*x + 0)#
mydata <- melt(y)#
mydata <- data.frame(id = mydata$L1, t = rep(1:T, n), x = x, y = mydata$value)#
mydata	<- data.table(mydata)#
mydata	<- mydata[,within:= c(0, y[-1] - y[-length(y)]), by = list(id)]#
mydata	<- mydata[,within:=within + mean(y[t==1])]#
#
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id), size = .25) + #
	geom_smooth(method = "lm") + #
	geom_smooth(aes(x, within), method = "lm", color = "red")
set.seed(11)#
n 	<- 10#
T	<- 20#
rho <- -.4#
ab	<- rmvnorm(n, rep(0, 2), matrix(c(1, rho, rho, 1), 2,2))#
ab[,2] <- ab[,2] * .1#
x 	<- 1:T#
y 	<- lapply(1:n, function(i) ab[i,1] + ab[i,2]*x + 0)#
mydata <- melt(y)#
mydata <- data.frame(id = mydata$L1, t = rep(1:T, n), x = x, y = mydata$value)#
mydata	<- data.table(mydata)#
mydata	<- mydata[,within:= c(0, y[-1] - y[-length(y)]), by = list(id)]#
mydata	<- mydata[,within:=within + mean(y[t==1])]#
#
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id), size = .25) + #
	geom_smooth(method = "lm") + #
	geom_smooth(aes(x, within), method = "lm", color = "red")
set.seed(20)#
n 	<- 10#
T	<- 20#
rho <- -.4#
ab	<- rmvnorm(n, rep(0, 2), matrix(c(1, rho, rho, 1), 2,2))#
ab[,2] <- ab[,2] * .1#
x 	<- 1:T#
y 	<- lapply(1:n, function(i) ab[i,1] + ab[i,2]*x + 0)#
mydata <- melt(y)#
mydata <- data.frame(id = mydata$L1, t = rep(1:T, n), x = x, y = mydata$value)#
mydata	<- data.table(mydata)#
mydata	<- mydata[,within:= c(0, y[-1] - y[-length(y)]), by = list(id)]#
mydata	<- mydata[,within:=within + mean(y[t==1])]#
#
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id), size = .25) + #
	geom_smooth(method = "lm") + #
	geom_smooth(aes(x, within), method = "lm", color = "red")
library(mvtnorm)#
library(reshape2)#
library(ggplot2)#
library(data.table)#
#
set.seed(1111)#
n 	<- 10#
T	<- 20#
rho <- -.4#
ab	<- rmvnorm(n, rep(0, 2), matrix(c(1, rho, rho, 1), 2,2))#
ab[,2] <- ab[,2] * .1#
x 	<- 1:T#
y 	<- lapply(1:n, function(i) ab[i,1] + ab[i,2]*x + 0)#
mydata <- melt(y)#
mydata <- data.frame(id = mydata$L1, t = rep(1:T, n), x = x, y = mydata$value)#
mydata	<- data.table(mydata)#
mydata	<- mydata[,within:= c(0, y[-1] - y[-length(y)]), by = list(id)]#
mydata	<- mydata[,within:=within + mean(y[t==1])]#
#
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id), size = .25) + #
	geom_smooth(method = "lm") + #
	geom_smooth(aes(x, within), method = "lm", color = "red")
set.seed(9)#
n 	<- 10#
T	<- 20#
rho <- -.4#
ab	<- rmvnorm(n, rep(0, 2), matrix(c(1, rho, rho, 1), 2,2))#
ab[,2] <- ab[,2] * .1#
x 	<- 1:T#
y 	<- lapply(1:n, function(i) ab[i,1] + ab[i,2]*x + 0)#
mydata <- melt(y)#
mydata <- data.frame(id = mydata$L1, t = rep(1:T, n), x = x, y = mydata$value)#
mydata	<- data.table(mydata)#
mydata	<- mydata[,within:= c(0, y[-1] - y[-length(y)]), by = list(id)]#
mydata	<- mydata[,within:=within + mean(y[t==1])]#
#
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id), size = .25) + #
	geom_smooth(method = "lm") + #
	geom_smooth(aes(x, within), method = "lm", color = "red")
n 	<- 10#
T	<- 20#
rho <- 0#
ab	<- rmvnorm(n, rep(0, 2), matrix(c(1, rho, rho, 1), 2,2))#
ab[,2] <- ab[,2] * .1#
x 	<- 1:T#
y 	<- lapply(1:n, function(i) ab[i,1] + ab[i,2]*x + 0)#
mydata <- melt(y)#
mydata <- data.frame(id = mydata$L1, t = rep(1:T, n), x = x, y = mydata$value)#
mydata	<- data.table(mydata)#
mydata	<- mydata[,within:= c(0, y[-1] - y[-length(y)]), by = list(id)]#
mydata	<- mydata[,within:=within + mean(y[t==1])]#
#
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id), size = .25) + #
	geom_smooth(method = "lm") + #
	geom_smooth(aes(x, within), method = "lm", color = "red")
set.seed(9)#
n 	<- 10#
T	<- 20#
rho <- -.4#
ab	<- rmvnorm(n, rep(0, 2), matrix(c(1, rho, rho, 1), 2,2))#
ab[,2] <- ab[,2] * .1#
x 	<- 1:T#
y 	<- lapply(1:n, function(i) ab[i,1] + ab[i,2]*x + 0)#
mydata <- melt(y)#
mydata <- data.frame(id = mydata$L1, t = rep(1:T, n), x = x, y = mydata$value)#
mydata	<- data.table(mydata)#
mydata	<- mydata[,within:= c(0, y[-1] - y[-length(y)]), by = list(id)]#
mydata	<- mydata[,within:=within + mean(y[t==1])]#
#
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id), size = .25) + #
	geom_smooth(method = "lm") + #
	geom_smooth(aes(x, within), method = "lm", color = "red")
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id), size = .25) + #
	geom_smooth(method = "lm") + #
	geom_smooth(data = subset(mydata, t>1) , aes(x, within), method = "lm", color = "red")
set.seed(9)#
n 	<- 10#
T	<- 20#
rho <- .4#
ab	<- rmvnorm(n, rep(0, 2), matrix(c(1, rho, rho, 1), 2,2))#
ab[,2] <- ab[,2] * .1#
x 	<- 1:T#
y 	<- lapply(1:n, function(i) ab[i,1] + ab[i,2]*x + 0)#
mydata <- melt(y)#
mydata <- data.frame(id = mydata$L1, t = rep(1:T, n), x = x, y = mydata$value)#
mydata	<- data.table(mydata)#
mydata	<- mydata[,within:= c(0, y[-1] - y[-length(y)]), by = list(id)]#
mydata	<- mydata[,within:=within + mean(y[t==1])]#
#
ggplot(mydata, aes(x, y)) + #
	geom_line(aes(group = id), size = .25) + #
	geom_smooth(method = "lm") + #
	geom_smooth(data = subset(mydata, t>1) , aes(x, within), method = "lm", color = "red")
3.44/54.98
638*.35/100
load("/Users/chaoqunchen/Downloads/expenditure results/reg_cpi/cluster se/cluster/expenditure_reg_sht_cpi_2016-04-04.rdata")
ggtmp1	<- subset(regrs1, model == "HomoPrice" & substr(DV,1,3) == "SHR" & Var == "ln_income")
head(ggtp1)
head(ggtmp1)
dim(ggtmp1)
ggtmp1
ggtmp1$Retail	<- factor(as.character(ggtmp1$DV), levels = paste("SHR.", gsub("\\s", ".", fmt_name[-1]), sep=""), #
						labels = fmt_name[-1])#
ord		<- order(ggtmp1$Estimate)#
ggtmp1$Retail 	<- factor(ggtmp1$Retail, levels = ggtmp1[ord,"Retail"])#
ord		<- levels(ggtmp1$Retail)
ggtmp1
head(mydat)
head(mydata)
dv_vec
dv_mat
colMeans(mydata[,dv_mat])
colMeans(mydata[,dv_mat], na.rm = T)
.3/8
.09/6.5
648*.3/100
648*.09/100
1.3/2.5
2.8/54
648*1.3/100
648*2.8/100
library(ggplot2)#
library(reshape2)#
library(data.table)#
library(plm)#
library(gridExtra)#
library(scales)#
library(systemfit)#
library(stargazer)#
library(gridExtra)
# Homogenous income effect for expenditure in SUR regressions#
ggtmp1	<- subset(regrs1, model == "HomoPrice" & substr(DV,1,3) == "SHR" & Var == "ln_income")#
ggtmp1$Retail	<- factor(as.character(ggtmp1$DV), levels = paste("SHR.", gsub("\\s", ".", fmt_name[-1]), sep=""), #
						labels = fmt_name[-1])#
ord		<- order(ggtmp1$Estimate)#
ggtmp1$Retail 	<- factor(ggtmp1$Retail, levels = ggtmp1[ord,"Retail"])#
ord		<- levels(ggtmp1$Retail)#
#
# Heterogenous income effect for expenditure in SUR regressions#
ggtmp2	<- subset(regrs1, model == "HeterPrice" & substr(DV,1,3) == "SHR" & substr(Var,1,9) == "ln_income")#
ggtmp2$Retail	<- factor(as.character(ggtmp2$DV), levels = paste("SHR.", gsub("\\s", ".", fmt_name[-1]), sep=""), #
						labels = fmt_name[-1])						#
ggtmp2$IncGrp	<- changelab(ggtmp2$Var, paste("ln_income",c("","_med","_high"),sep=""), c("Low", "Med", "High"))#
ggtmp2$IncGrp	<- factor(ggtmp2$IncGrp, levels = rev(levels(ggtmp2$IncGrp)), ordered = TRUE)#
ggtmp2$Retail 	<- factor(ggtmp2$Retail, levels = ord)#
#
# For median and high income group, the estiamtes are difference relative to low-income group#
# So, we add the baseline (the estimate for low-income group) to the difference#
sel		<- ggtmp2$Var == "ln_income"#
tmp		<- ggtmp2[sel,"Estimate"]#
names(tmp)	<- ggtmp2[sel,"DV"]#
tmp1	<- tmp[as.character(ggtmp2$DV)]#
tmp1[sel]	<- 0#
ggtmp2$Estimate1	<- ggtmp2$Estimate + tmp1#
tmp		<- ggtmp2[sel,"Std..Error"]#
names(tmp)	<- ggtmp2[sel,"DV"]#
tmp1	<- tmp[as.character(ggtmp2$DV)]#
tmp1[sel]	<- 0#
ggtmp2$StdErr	<- sqrt(ggtmp2$Std..Error^2 + tmp1^2)#
tmp		<- ggtmp2[sel,"cls_se"]#
names(tmp)	<- ggtmp2[sel,"DV"]#
tmp1	<- tmp[as.character(ggtmp2$DV)]#
tmp1[sel]	<- 0#
ggtmp2$Cluster_se	<- sqrt(ggtmp2$cls_se^2 + tmp1^2)#
# Find the range of estimates#
mylim		<- range(c(with(ggtmp1, Estimate - 1.96*Std..Error), with(ggtmp1, Estimate + 1.96*Std..Error), #
					   with(ggtmp2, Estimate1-1.96*StdErr), with(ggtmp2, Estimate1 + 1.96 * StdErr)))#
cat("y axis range is", mylim, "\n")
plots	<- list(NULL)#
plots[[1]]	<- ggplot(ggtmp1, aes(Retail, Estimate)) + #
			geom_pointrange(aes(y = Estimate, ymin = Estimate-1.96*Std..Error, ymax = Estimate + 1.96 * Std..Error), width=0.25) + #
			ylim(mylim) + #
			xlab("Retail format") + coord_flip()#
plots[[2]]	<- ggplot(ggtmp2, aes(Retail, Estimate1, col = IncGrp)) + #
			geom_pointrange(aes(ymin = Estimate1-1.96*StdErr, ymax = Estimate1 + 1.96 * StdErr, col = IncGrp), #
					position=position_dodge(width=0.3)) + #
			scale_color_grey(name="Income\ngroup", start = 0, end = .6) +  #
			ylim(mylim) + #
			xlab("Retail format") + ylab("Estimate")+ coord_flip() + #
			guides(fill = guide_legend(reverse = TRUE), color = guide_legend(reverse = TRUE)) #
plots[[3]]	<- get_legend(plots[[2]])#
plots[[2]]	<- plots[[2]] + theme(legend.position="none")
get_legend<-function(myggplot){#
  tmp <- ggplot_gtable(ggplot_build(myggplot))#
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")#
  legend <- tmp$grobs[[leg]]#
  return(legend)#
}
plots	<- list(NULL)#
plots[[1]]	<- ggplot(ggtmp1, aes(Retail, Estimate)) + #
			geom_pointrange(aes(y = Estimate, ymin = Estimate-1.96*Std..Error, ymax = Estimate + 1.96 * Std..Error), width=0.25) + #
			ylim(mylim) + #
			xlab("Retail format") + coord_flip()#
plots[[2]]	<- ggplot(ggtmp2, aes(Retail, Estimate1, col = IncGrp)) + #
			geom_pointrange(aes(ymin = Estimate1-1.96*StdErr, ymax = Estimate1 + 1.96 * StdErr, col = IncGrp), #
					position=position_dodge(width=0.3)) + #
			scale_color_grey(name="Income\ngroup", start = 0, end = .6) +  #
			ylim(mylim) + #
			xlab("Retail format") + ylab("Estimate")+ coord_flip() + #
			guides(fill = guide_legend(reverse = TRUE), color = guide_legend(reverse = TRUE)) #
plots[[3]]	<- get_legend(plots[[2]])#
plots[[2]]	<- plots[[2]] + theme(legend.position="none")
grid.arrange(plots[[1]], plots[[2]], plots[[3]], nrow = 1, widths = c(.45, .45, .1))
head(ggtmp2)
ggtmp2	<- subset(regrs1, model == "HeterPrice" & substr(DV,1,3) == "SHR" & substr(Var,1,9) == "ln_income")
dim(ggtmp2)
ggtmp2
638*.36/100
2.62/41.98
# Explore utility function with corner and interior solutions. #
#
# U = gamma1*psi1*log(x1/gamma1+1) + gamma2*psi2*log(x2/gamma2+1)#
# Budget constraint: x1+x2=y#
#
library(ggplot2)#
#
u <- function(gamma,psi,x1,x2){#
	gamma[1]*psi[1]*log(x1/gamma[1]+1) + gamma[2]*psi[2]*log(x2/gamma[2]+1)#
}#
#
x2.fn <- function(x1,ubar,gamma,psi){#
	(exp((ubar-gamma[1]*psi[1]*log(x1/gamma[1]+1))/(gamma[2]*psi[2]) ) - 1)*gamma[2]#
}#
#
y <- 3#
psi.list <- list(c(1,1),c(.5,1.5))#
gamma.list <- list(c(.1,.1),c(1,1))#
#
x1 <- seq(-1,5,.005)#
ggtmp <- NULL#
ubar <- matrix(c(.555,1.83,#
				 .582,2.1),2,2,byrow=T)					# The utility at tangent#
for(ip in 1:length(psi.list)){#
	for(ig in 1:length(gamma.list)){#
		x2 <- x2.fn(x1,ubar=ubar[ip,ig],gamma=gamma.list[[ig]],psi=psi.list[[ip]])#
		tmp <- data.frame(x1=x1,x2=x2,psi=ip,gamma=ig,group="optimal")#
		ggtmp <- rbind(ggtmp,tmp)#
	}#
}#
#
ubar <- matrix(c(.3,.5,#
				 .4,1),2,2,byrow=T)					# The utility at lower level#
for(ip in 1:length(psi.list)){#
	for(ig in 1:length(gamma.list)){#
		x2 <- x2.fn(x1,ubar=ubar[ip,ig],gamma=gamma.list[[ig]],psi=psi.list[[ip]])#
		tmp <- data.frame(x1=x1,x2=x2,psi=ip,gamma=ig,group="lower")#
		ggtmp <- rbind(ggtmp,tmp)#
	}#
}#
#
ggtmp$psi <- factor(ggtmp$psi,levels=1:2,labels=c("psi[1]==1~psi[2]==1","psi[1]==.5~psi[2]==1.5"))#
ggtmp$gamma <- factor(ggtmp$gamma,levels=1:2,labels=c("gamma[1]==.1~gamma[2]==.1","gamma[1]==1~gamma[2]==1"))
ggplot(ggtmp,aes(x1,x2)) + geom_line(aes(group=group)) + #
		geom_abline(intercept=3,slope=-1,linetype=3) + #
		ylim(c(-1,5)) + xlim(c(-1,5)) + #
		geom_hline(yintercept=0,size=.5,linetype=2) +#
		geom_vline(xintercept=0,size=.5,linetype=2) +#
		facet_grid(psi~gamma,labeller=label_parsed) +#
		theme_bw() +#
		theme(panel.grid=element_blank())
# A new demonstration#
y <- 3#
psi.list <- list(c(1.5,.5),c(1,1),c(.5,1.5))#
gamma <- c(1,1)#
#
x1 <- seq(-1,5,.005)#
ggtmp <- NULL#
ubar <- c(2.11,1.83,2.11)				# The utility at tangent#
for(ip in 1:length(psi.list)){#
	x2 <- x2.fn(x1,ubar=ubar[ip],gamma=gamma,psi=psi.list[[ip]])#
	tmp <- data.frame(x1=x1,x2=x2,psi=ip)#
	ggtmp <- rbind(ggtmp,tmp)#
}#
ggtmp$psi <- factor(ggtmp$psi,levels=1:3,labels=c("psi[1]==1.5~psi[2]==.5","psi[1]==1~psi[2]==1","psi[1]==.5~psi[2]==1.5"))
ggplot(ggtmp,aes(x1,x2)) + geom_line() + #
		geom_abline(intercept=3,slope=-1,linetype=3) + #
		ylim(c(-1,5)) + xlim(c(-1,5)) + #
		geom_hline(yintercept=0,size=.5,linetype=2) +#
		geom_vline(xintercept=0,size=.5,linetype=2) +#
		facet_grid(.~psi,labeller=label_parsed) +#
		theme_bw() +#
		theme(panel.grid=element_blank())
pdf("~/Desktop/graph_CES_utility.pdf",width=6.5,height=6.5*.6)#
ggplot(ggtmp,aes(x1,x2)) + geom_line() + #
		geom_abline(intercept=3,slope=-1,linetype=3) + #
		ylim(c(-1,5)) + xlim(c(-1,5)) + #
		geom_hline(yintercept=0,size=.5,linetype=2) +#
		geom_vline(xintercept=0,size=.5,linetype=2) +#
		facet_grid(.~psi,labeller=label_parsed) +#
		theme_bw() +#
		theme(panel.grid=element_blank())#
dev.off()
load("/Users/chaoqunchen/Desktop/MDCEV_stan_cpi_seg2_sub20_chain4_iter2500_burn1250_thin5.rdata")
numsim
ls()
numiter
library(rstan)
plot(sim)
arr_id
## load data and fit model#
data(Mandible)#
fm <- lm(length ~ age, data=Mandible, subset=(age <= 28))#
#
## the following commands lead to the same tests:#
summary(fm)#
coeftest(fm)#
#
## a z test (instead of a t test) can be performed by#
coeftest(fm, df = Inf)
library(lmtest)
## load data and fit model#
data(Mandible)#
fm <- lm(length ~ age, data=Mandible, subset=(age <= 28))#
#
## the following commands lead to the same tests:#
summary(fm)#
coeftest(fm)#
#
## a z test (instead of a t test) can be performed by#
coeftest(fm, df = Inf)
nx
# Outcome variables as matrix#
sel		<- paste("SHR_", gsub("\\s", "_", fmt_name), sep="")#
shr		<- as.matrix(mydata[,sel])#
y		<- as.vector(mydata$dol)#
ln_inc	<- mydata$ln_inc#
sel		<- paste("PRC_", gsub("\\s", "_", fmt_name), sep="")#
price	<- as.matrix(mydata[,sel])#
#
# Select the index that has the positive expenditure#
tmp 	<- price * 1 *(shr> 0)#
s1_index<- apply(tmp, 1, which.max)#
#
# Match retailers' attributes#
tmp1	<- unique(fmt_attr$year)#
tmp2	<- unique(fmt_attr$scantrack_market_descr)#
tmp		<- paste(rep(tmp2, each=length(tmp1)), rep(tmp1, length(tmp2)), sep="-")#
tmpn	<- 1:length(tmp)		#
names(tmpn) <- tmp#
sel 	<- with(mydata, paste(scantrack_market_descr,year, sep="-"))#
sel1	<- tmpn[sel]#
selcol	<- c("size_index", "ln_upc_per_mod", "ln_num_module","overall_prvt")#
nx 		<- length(selcol) * 2 + R-1#
#
X_list 	<- vector("list", length=length(fmt_name))#
for(i in 1:length(fmt_name)){#
	sel2		<- fmt_attr$channel_type == fmt_name[i]#
	tmp			<- fmt_attr[sel2,selcol]#
	tmp1 		<- as.matrix(tmp[sel1,])#
	tmp2		<- matrix(0, nrow(shr), R-1)#
	if(i < beta0_base){#
		tmp2[,i]	<- ln_inc#
	}else if(i > beta0_base){#
		tmp2[,(i-1)] <- ln_inc#
	}#
	X_list[[i]]	<- cbind(tmp2, tmp1, tmp1 * ln_inc)#
}
# following shows how tensor pruduct deals nicely with #
# badly scaled covariates (range of x 5% of range of z )#
require(mgcv)#
test1 <- function(x,z,sx=0.3,sz=0.4) { #
  x <- x*20#
  (pi**sx*sz)*(1.2*exp(-(x-0.2)^2/sx^2-(z-0.3)^2/sz^2)+#
  0.8*exp(-(x-0.7)^2/sx^2-(z-0.8)^2/sz^2))#
}#
n <- 500#
old.par <- par(mfrow=c(2,2))#
x <- runif(n)/20;z <- runif(n);#
xs <- seq(0,1,length=30)/20;zs <- seq(0,1,length=30)#
pr <- data.frame(x=rep(xs,30),z=rep(zs,rep(30,30)))#
truth <- matrix(test1(pr$x,pr$z),30,30)#
f <- test1(x,z)#
y <- f + rnorm(n)*0.2#
b1 <- gam(y~s(x,z))
persp(xs,zs,truth);title("truth")#
vis.gam(b1);title("t.p.r.s")
b2 <- gam(y~te(x,z))#
vis.gam(b2);title("tensor product")
b3 <- gam(y~ ti(x) + ti(z) + ti(x,z))#
vis.gam(b3);title("tensor anova")
6.11/67.9
14.93/238
getwd()
basename()
basename(getwd())
dirname(getwd())
list.files()
?do.call
library(rstan)
## Not run: #
showClass("stanfit")#
ecode <- '#
  parameters {#
    real<lower=0> y[2];#
  } #
  model {#
    y ~ exponential(1);#
  }#
'#
fit <- stan(model_code = ecode, iter = 10, chains = 1)#
fit2 <- stan(fit = fit)
print(fit2)#
plot(fit2)
ainfo <- get_adaptation_info(fit2)
ainfo
sp <- get_sampler_params(fit2)#
sp2 <- get_sampler_params(fit2, inc_warmup = FALSE)#
head(sp[[1]])
lp <- log_prob(fit, c(1, 2))#
grad <- grad_log_prob(fit, c(1, 2))#
lp2 <- attr(grad, "log_prob") # should be the same as "lp"
n <- get_num_upars(fit)
n
y1 <- list(y = rep(1, 2))
ny
uy
y1star <- constrain_pars(fit, uy)
uy <- unconstrain_pars(fit, y1) #
## uy should be c(0, 0) since here the log transformation is used#
y1star <- constrain_pars(fit, uy)
16+16+8
load("/Users/chaoqunchen/Desktop/ctrfact_seq_seg3_sim1000_2016-04-30.rdata")
ls()
6.38*.02
library(rstan)
?stan
2/32
65*.7
49.85/797.60
n <- 200
x <- runif(n)
x
xm <- cbind(x, 1-x)
cor(xm)
sd(rnorm(30))
sd(rnorm(50))
6.11/67.90
sample(c("m", "h"), 1)
638*.49
638*.49/100
40.5/55
d <- structure(list(r = structure(c(1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,#
     1L, 1L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L), .Label = c("r1","r2"),#
     class = "factor"), s = structure(c(1L, 1L, 1L, 1L, 1L, #
     2L, 2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L), #
    .Label = c("s1","s2"), class = "factor"), rs = structure(c(1L, 1L,#
     1L,1L, 1L,2L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L, 3L, 4L, 4L, 4L, 4L, 4L),#
    .Label = c("r1s1","r1s2", "r2s1", "r2s2"), class = "factor"), #
     y = c(19.3788027518437, 23.832287726332, 26.2533235300492,#
     15.962906892112, 24.2873740664331, 28.5181676764727, 25.2757801195961,#
     25.3601044326474, 25.3066440027202, 24.3298865128677, 32.5684219007394,#
     31.0048406654209, 31.671238316086, 34.1933764518288, 36.8784821769123,#
     41.6691435168277, 40.4669714825801, 39.2664137501106, 39.4884849591932,#
     49.247505535468)), .Names = c("r","s", "rs", "y"), #
     row.names = c(NA, -20L), class = "data.frame")
lm0 <- lm(y ~ r*s, data=d)#
lm1 <- lm(y ~ r + s + r:s, data=d)
lm2 <- lm(y ~ r + s + rs, data=d)
lm1
lm2
a <- model.matrix(y~r:s, data = d)
head(a)
b <- model.matrix(y~r*s, data = d)
head(b)
head(d)
d$x <- runif(nrow(d))
c <- model.matrix(y ~ x*r:s, data = d)
head(c)
c <- model.matrix(y ~ x:r:s, data = d)
head(c)
c <- model.matrix(y ~ x:r:s - 1, data = d)
head(c)
head(d)
(468.36-448.69)/448.69
s <- c(448.69, 468.36, 487.65, 487.19, 495.17)
diff(s)
diff(s)/s[-length(s)]
s <- c(s, 519.4)
diff(s)/s[-length(s)]
dat <- read.csv("~/Documents/Research/Store switching/processed data/2_panelists.csv",header = T)
dim(dat)
head(dat)
library(foreach)
?foreach
5193*.99
5193*.995
5193*.995 - 5193
800/1200
2/3
2/3*210
?which
260*.8
260*.2
163*.2
212*.2
library(foreach)
?foreach
a <- c(1)
a[1]
library(maxLik)
?maxLik
library(stargazer)
?stargazer
# MDCEV simulation #
#
library(reshape2)#
library(ggplot2)#
library(Rcpp)#
library(RcppArmadillo)#
library(maxLik)#
library(evd)#
library(nloptr)#
#
setwd("~/Documents/Research/Store switching/Exercise/Multiple_discrete_continuous_model")#
model_name <- "MDCEV_share"#
#
# sourceCpp(paste(model_name, ".cpp", sep=""))#
source("0_Allocation_function.R")#
#
#########################
# Estimation functions ##
#########################
src <- #
'#
#include <RcppArmadillo.h>#
#include <algorithm>#
#include <Rcpp.h>#
using namespace Rcpp;#
using namespace arma;#
// [[Rcpp::depends(RcppArmadillo)]]#
#
// [[Rcpp::export]]#
List MDCEV_ll_fnC(vec param, int nx, mat shr, vec y, vec s1_index, mat p, List X_list, int base=0){#
	int R = shr.n_cols, N = shr.n_rows;#
	vec beta0_norm = zeros(1), gamma0_norm = ones<vec>(1); #
	vec beta = param.subvec(0, nx-1), beta0_sub = param.subvec(nx, nx+R-2), #
		gamma1	= param.subvec(nx+R-1, 2*nx+R-2), gamma0 = param.subvec(2*nx+R-1, 2*(nx+R)-2);#
	vec beta0 = zeros(R);#
	if(base == 0){#
		beta0 	= join_cols(beta0_norm, beta0_sub);#
	}else{#
		int j=0;#
		for(int i=0; i<R; i++){#
			if(i==base - 1){#
				continue;#
			}else{#
				beta0(i) = beta0_sub(j); #
				j++; #
			}#
		}#
	}	 #
	double sigma = exp(param(2*(nx+R)-1));#
#
	// Utility V_tilde and indicator matrix for the original R alternatives;#
	mat V_tilde = zeros(N, R), d_tilde = zeros(N, R), gamma = zeros(N, R);#
	umat sgn_shr_tilde = shr > 0;#
	for(int i=0; i<R; i++){#
		mat Xtmp 		= X_list[i];#
		gamma.col(i)	= exp(Xtmp * gamma1 + gamma0(i)); #
		d_tilde.col(i)	= shr.col(i) + gamma.col(i)%p.col(i)/y;#
		V_tilde.col(i) 	= Xtmp * beta + beta0(i) - log(d_tilde.col(i)/gamma.col(i));#
	}#
	// Jacobean matrix determinant; #
	mat d_sgn = d_tilde % sgn_shr_tilde;#
	vec J = log(sum(d_sgn, 1)) - sum(log(d_tilde) % sgn_shr_tilde, 1);#
	mat sgn_shr = arma::conv_to<arma::mat>::from(sgn_shr_tilde); #
	vec M = sum(sgn_shr, 1);#
	// Sum up the log likelihood; #
	vec ll = J - (M - ones<vec>(N)) * log(sigma) + sum(V_tilde % sgn_shr_tilde/sigma, 1) #
			- M % log(sum(exp(V_tilde/sigma), 1)) ; #
	List out = List::create(_["ll"]=ll, _["V_tilde"]=V_tilde);#
	return(out);#
}#
// [[Rcpp::export]]#
colvec MDCEV_LogLike_fnC(vec param, int nx, vec s1_index, arma::mat shr, vec y, arma::mat p, List X_list, int base=0){#
	List ll_out	= MDCEV_ll_fnC(param, nx, shr, y, s1_index, p, X_list, base);#
	colvec llvec 	= ll_out["ll"];#
// 	NumericVector ll = as<NumericVector>(wrap(llvec));#
// 	ll.attr("gradient") = grad;#
	return(llvec);#
}#
'#
sourceCpp(code = src)
##################
# Simualte data ##
##################
# Set paraemters #
R		<- 3 		# Number of alternatives#
Ra		<- R		# Number of alternatives + number of outside options#
exp_outside <- quant_outside <- FALSE#
beta0 	<- c(0, -1, -1)#
beta	<- c(.5, -.7)#
gamma1	<- c(-1, .6)#
gamma0 	<- c(-1, 0, -1)#
sigma 	<- 1#
qz_cons	<- Inf#
#
# Simulate data #
set.seed(666666)#
nx 		<- length(beta)#
N 		<- 500		# Number of observations#
X_arr 	<- array(rnorm(N*R*nx), c(R, N, nx))#
X_list  <- lapply(1:R, function(i) X_arr[i,,])#
price 	<- matrix(runif(N*R, 2, 4), N, R)#
Q		<- runif(N, 1, 20)#
y		<- rowSums(price) * Q/R #
#
par(mfrow=c(3,1))#
hist(y, breaks=100)#
hist(Q, breaks=100)#
hist(as.vector(price), breaks=100)#
#
eps_draw<- matrix(rgumbel(N*R), N, R)#
xbeta	<- do.call(cbind, lapply(1:R, function(i) X_list[[i]] %*% beta + beta0[i]))#
psi		<- exp(xbeta + eps_draw)#
gamma	<- do.call(cbind, lapply(1:R, function(i) X_list[[i]]%*%gamma1 + gamma0[i]))#
gamma	<- exp(gamma)#
e_mat <- matrix(NA, N, Ra)#
for(i in 1:N){#
	tmp	<- Allocation_fn(y = y[i], psi = psi[i,], gamma[i,], Q = Inf, price = price[i,], R, Ra, qz_cons, exp_outside, quant_outside)#
	e_mat[i,] <- tmp$e#
}
Ra
eR 	<- e_mat[,1:R]
mean(eR==0)
eps <- 1e-4#
eR 	<- e_mat[,1:R]#
eR[eR<=eps] <- 0#
mean(eR==0)
sel	<- apply(eR, 1, function(x) !all(x==0))#
eR 	<- eR[sel,]#
Q	<- Q[sel]#
y	<- y[sel]#
price <- price[sel,]#
X_list <- lapply(X_list, function(x) x[sel,])#
e1_index <- apply(eR, 1, function(x) which(x== min(x[x>0])))#
shr		<- eR/y
# Esitmation #
MDCEV_wrapper <- function(param){#
	MDCEV_LogLike_fnC(param, nx, s1_index = e1_index, shr = shr, y = y, p=price, X_list = X_list)#
}#
#
# Estimation with multiple initial values (full set of parameters)#
theta_init0	<- c(beta, beta0[-1], gamma1, gamma0, log(sigma))#
theta_init2	<- theta_init1 <- theta_init0#
theta_init1[1:(nx+R)] <- theta_init0[1:(nx+R)] + rnorm(nx+R)#
theta_init2[1:(nx+R)] <- rep(1, nx+R)#
theta_init 	<- list(theta_init0, theta_init1, theta_init2)#
system.time(tmp <- MDCEV_wrapper(theta_init[[1]]))
tmp_sol <- vector("list", length(theta_init))#
pct <- proc.time()#
for(i in 1:length(theta_init)){#
	names(theta_init[[i]]) <- c(paste("beta_",1:nx, sep=""), paste("beta0_",2:R,sep=""), #
								paste("gamma1_",1:nx, sep=""), paste("gamma0_",1:R, sep=""),#
								"ln_sigma")	#
	tmp_sol[[i]]	<- maxLik(MDCEV_wrapper, start=theta_init[[i]], method="BFGS")#
}#
sel 	<- which.max(sapply(tmp_sol, function(x) ifelse(is.null(x$maximum), NA, x$maximum)))#
sol		<- tmp_sol[[sel]]#
lapply(tmp_sol, summary)
beta
cbind(True = theta_init0, sapply(tmp_sol, coef))
theta_init2 <- rep(1, length(theta_init2))
i <- 3
names(theta_init[[i]]) <- c(paste("beta_",1:nx, sep=""), paste("beta0_",2:R,sep=""), #
								paste("gamma1_",1:nx, sep=""), paste("gamma0_",1:R, sep=""),#
								"ln_sigma")	#
	tmp_sol[[i]]	<- maxLik(MDCEV_wrapper, start=theta_init[[i]], method="BFGS")
theta_init 	<- list(theta_init0, theta_init1, theta_init2)
# Estimation with multiple initial values (full set of parameters)#
theta_init0	<- c(beta, beta0[-1], gamma1, gamma0, log(sigma))#
theta_init2	<- theta_init1 <- theta_init0#
theta_init1[1:(nx+R)] <- theta_init0[1:(nx+R)] + rnorm(nx+R)#
theta_init2 <- rep(1, length(theta_init2))#
theta_init 	<- list(theta_init0, theta_init1, theta_init2)#
system.time(tmp <- MDCEV_wrapper(theta_init[[1]]))#
#
tmp_sol <- vector("list", length(theta_init))#
pct <- proc.time()#
for(i in 1:length(theta_init)){#
	names(theta_init[[i]]) <- c(paste("beta_",1:nx, sep=""), paste("beta0_",2:R,sep=""), #
								paste("gamma1_",1:nx, sep=""), paste("gamma0_",1:R, sep=""),#
								"ln_sigma")	#
	tmp_sol[[i]]	<- maxLik(MDCEV_wrapper, start=theta_init[[i]], method="BFGS")#
}#
sel 	<- which.max(sapply(tmp_sol, function(x) ifelse(is.null(x$maximum), NA, x$maximum)))#
sol		<- tmp_sol[[sel]]#
lapply(tmp_sol, summary)#
cbind(True = theta_init0, sapply(tmp_sol, coef))
