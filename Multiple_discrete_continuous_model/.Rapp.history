library(ggplot2)#
library(reshape2)#
library(scatterplot3d)#
library(maxLik)#
library(Rcpp)#
library(RcppGSL)#
library(glmmML)#
#
 sourceCpp("~/Documents/Research/Store switching/Exercise/Basket DP/0_DAM_functions.cpp")
make_plot	<- TRUE#
#
control_list <- list(	value_max_iter 	= 500,#
						tol				= 1e-6,#
						display_freq	= 20,#
						brent_tol		= 0.00001, #
						brent_max_iter 	= 300,#
						inter_spline	= TRUE#
				)
run_id <- "w0t0"
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 1, tau_b = 3, tau1 = .3, tau2 = .5)#
if(substr(run_id, 3,4)=="t0"){#
	param["tau_b"] <- 0#
}#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(0.1, .5, 0.1, .5)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(250, 300, 350)#
n_Inc		<- 4#
#
# Initiate states#
my_grid <- list(I = c(0, 1, 2, 3, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .1#
rho1		<- .15#
sigma0 		<- .15#
sigma1 		<- .35#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	if(substr(run_id, 1,2)=="w0"){#
		rep(0, length(y))#
	}else if (substr(run_id, 1,2)=="w1"){#
		-.01*k*y^2 + .6*y#
	}else{#
		.015*k*y^2 + .4*y#
	} 	#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 98:106#
	state[plot_state,]#
	choice_k 	<- 4#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	tmp1 		<- cal_flow(DP_list, c_grid, state[plot_state,], choice_k, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	dimnames(tmp1) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp1		<- melt(tmp1)#
	sel 		<- is.na(ggtmp1$c)#
	ggtmp1[sel,"c"] <- tmp_cstar#
	ggtmp1$max_pnt <- 0#
	ggtmp1[sel,"max_pnt"] <- 1	#
	ggtmp 		<- data.frame(rbind(ggtmp, ggtmp1), v=rep(c("value","flow"), each=nrow(ggtmp1)) )#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value, linetype = v, shape = v)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}
##############
# Functions ##
##############
matrix_expand <- function(mat, vec){#
	n1	<- nrow(mat)#
	n2	<- length(vec)#
	sel	<- rep(1:n1, n2)#
	mat_new <- cbind(mat[sel,], rep(vec, each=n1))#
	return(mat_new)#
}#
#
my_lag 	<- function(x){#
	return(c(NA, x[-length(x)]))#
}#
#
FlowU 	<- function(c, I, lny, Inc, Rc, k, Q, TR, param, price_min){#
	lambda 	<- param["lambda"]#
	tau_b	<- param["tau_b"]#
	tau1	<- param["tau1"]#
# 	tripcost<- param[(3+k)]#
	tau2	<- param["tau2"]#
	I_next	<- I + Q - c#
	omega	<- omega_fn(k, lny)#
	borrow_cost <- 0#
	if(exp(lny)/price_min < Q){#
		borrow_cost <-  tau_b * log(price_min*Q - exp(lny))#
	}#
	u 		<- lambda*log(c+0.01) - tau1*I_next - tau2*TR + omega - borrow_cost#
	return(u)#
}#
#
cal_flow 	<- function(DP_list, c_grid, DataState, choice_k, cstar){#
	ns		<- nrow(DataState)#
	nc		<- length(c_grid)#
	out		<- matrix(NA, ns, nc+1)#
	Q_grid 	<- DP_list$Q_grid#
	TR_grid	<- DP_list$TR_grid#
	param 	<- DP_list$param#
	price	<- DP_list$price#
	for(i in 1:ns){#
		for(j in 1:nc){#
			out[i,j] <- FlowU(c_grid[j], DataState[i,1], DataState[i,2], DataState[i,3], #
							DataState[i,4], choice_k, Q_grid[choice_k], TR_grid[choice_k], #
							param, min(price))#
		}#
		out[i, (nc+1)] <- FlowU(cstar[i], DataState[i,1], DataState[i,2], DataState[i,3], #
							DataState[i,4], choice_k, Q_grid[choice_k], TR_grid[choice_k], #
							param, min(price))#
	}#
	return(out)#
}
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 1, tau_b = 3, tau1 = .3, tau2 = .5)#
if(substr(run_id, 3,4)=="t0"){#
	param["tau_b"] <- 0#
}#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(0.1, .5, 0.1, .5)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(250, 300, 350)#
n_Inc		<- 4#
#
# Initiate states#
my_grid <- list(I = c(0, 1, 2, 3, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .1#
rho1		<- .15#
sigma0 		<- .15#
sigma1 		<- .35#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	if(substr(run_id, 1,2)=="w0"){#
		rep(0, length(y))#
	}else if (substr(run_id, 1,2)=="w1"){#
		-.01*k*y^2 + .6*y#
	}else{#
		.015*k*y^2 + .4*y#
	} 	#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 98:106#
	state[plot_state,]#
	choice_k 	<- 4#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	tmp1 		<- cal_flow(DP_list, c_grid, state[plot_state,], choice_k, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	dimnames(tmp1) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp1		<- melt(tmp1)#
	sel 		<- is.na(ggtmp1$c)#
	ggtmp1[sel,"c"] <- tmp_cstar#
	ggtmp1$max_pnt <- 0#
	ggtmp1[sel,"max_pnt"] <- 1	#
	ggtmp 		<- data.frame(rbind(ggtmp, ggtmp1), v=rep(c("value","flow"), each=nrow(ggtmp1)) )#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value, linetype = v, shape = v)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
set.seed(666) #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
if(make_plot){#
	ggtmp <- my_data[[1]]#
	ggtmp$Q <- bskt_typeQ[ggtmp$k]#
	ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
	ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
	quartz()#
	ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
			facet_grid(variable ~ ., scales="free_y") + #
			labs(title = "Simulated sequence")#
}
param
run_id <- "w2t0"
######################
# Simulation set up ##
######################
# Parameter #
param 		<- c(lambda = 1, tau_b = 3, tau1 = .3, tau2 = .5)#
if(substr(run_id, 3,4)=="t0"){#
	param["tau_b"] <- 0#
}#
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(0.1, .5, 0.1, .5)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(250, 300, 350)#
n_Inc		<- 4#
#
# Initiate states#
my_grid <- list(I = c(0, 1, 2, 3, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .1#
rho1		<- .15#
sigma0 		<- .15#
sigma1 		<- .35#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	if(substr(run_id, 1,2)=="w0"){#
		rep(0, length(y))#
	}else if (substr(run_id, 1,2)=="w1"){#
		-.01*k*y^2 + .6*y#
	}else{#
		.015*k*y^2 + .4*y#
	} 	#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 98:106#
	state[plot_state,]#
	choice_k 	<- 4#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	tmp1 		<- cal_flow(DP_list, c_grid, state[plot_state,], choice_k, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	dimnames(tmp1) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp1		<- melt(tmp1)#
	sel 		<- is.na(ggtmp1$c)#
	ggtmp1[sel,"c"] <- tmp_cstar#
	ggtmp1$max_pnt <- 0#
	ggtmp1[sel,"max_pnt"] <- 1	#
	ggtmp 		<- data.frame(rbind(ggtmp, ggtmp1), v=rep(c("value","flow"), each=nrow(ggtmp1)) )#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value, linetype = v, shape = v)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
set.seed(666) #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
if(make_plot){#
	ggtmp <- my_data[[1]]#
	ggtmp$Q <- bskt_typeQ[ggtmp$k]#
	ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
	ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
	quartz()#
	ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
			facet_grid(variable ~ ., scales="free_y") + #
			labs(title = "Simulated sequence")#
}
param
omega_fn(2, 4)
param["tau1"] <- .1
beta		<- .95#
K 			<- 4#
bskt_typeQ 	<- c(0.1, .5, 0.1, .5)#
bskt_typeTR <- c(7,7,9,9)#
price 		<- c(250, 300, 350)#
n_Inc		<- 4#
#
# Initiate states#
my_grid <- list(I = c(0, 1, 2, 3, 4, 5 ), #
				y = c(3, 4.8, 5.2, 5.5, 5.8, 6),  #
				Inc	= 1:n_Inc, #
				Rc = c(0, 1))#
state	<- as.matrix(my_grid[[1]], ncol=1) #
for(i in 2:length(my_grid)){#
	state <- matrix_expand(state, my_grid[[i]])#
}#
colnames(state) <- c("I", "y", "Inc","Rc")#
summary(state)#
#
# Distribution kernal of expenditure #
gh_num_nodes <- 5#
y_weight	<- ghq(gh_num_nodes, modified = F)$weights#
y_nodes 	<- ghq(gh_num_nodes, modified = F)$zeros#
kappa0 		<- c(4, 4.2, 4.8, 4.7)#
kappa1		<- kappa0 - .1#
rho0		<- .1#
rho1		<- .15#
sigma0 		<- .15#
sigma1 		<- .35#
y_kernal	<- list(nodes = y_nodes, weight = y_weight, #
				kappa = cbind(kappa0, kappa1), rho = c(rho0, rho1), sigma = c(sigma0, sigma1))#
#
# Markov probability of income transition#
Inc_weight 	<- rbind(diag(n_Inc), diag(n_Inc))#
Inc_weight[1,]	<- c(.75, .25,	0,	0)#
Inc_weight[2,]	<- c(.1, 	.9,	0,	0)#
Inc_weight[3,]	<- c(0,		.1,	.8,	.1)#
Inc_weight[4,]	<- c(0,		0,	.2,	.8)#
Inc_weight[5,]	<- c(.8, 	.2,	0,	0)#
Inc_weight[6,]	<- c(.2, 	.8,	0,	0)#
Inc_weight[7,]	<- c(0,		.2,	.7,	.1)#
Inc_weight[8,]	<- c(0,		.1,	.2,	.7)#
# Omega function#
omega_fn 	<- function(k, y){#
	if(substr(run_id, 1,2)=="w0"){#
		rep(0, length(y))#
	}else if (substr(run_id, 1,2)=="w1"){#
		-.01*k*y^2 + .6*y#
	}else{#
		.015*k*y^2 + .4*y#
	} 	#
}#
tmp 		<- seq(0, 7, by=.1)#
ggtmp		<- sapply(1:K, function(i) omega_fn(i,tmp))#
dimnames(ggtmp) <- list(y=tmp, k=1:K)#
ggtmp		<- melt(ggtmp)#
if(make_plot){#
	ggplot(ggtmp, aes(y, value, col=factor(k))) + geom_point() + geom_line() #
}#
#
#####################
# Dynamic solution ##
#####################
# DP structure #
DP_list	<- list(state 	= state, K = K, #
value_fn= 2 * log(state[,1] + 1), #
# 				value_fn= 0, #
				param  	= param, #
				beta 	= beta,#
				Q_grid	= bskt_typeQ, #
				TR_grid = bskt_typeTR, #
				omega	= omega_fn, #
				price	= price,#
				y_kernal= y_kernal, #
				Inc_weight = Inc_weight,#
				Iteration = 0, #
				status = 1#
				)#
policy_k_guess <- rep(1, nrow(state))#
tmp			<- V_initC(param, DP_list, policy_k = policy_k_guess, policy_c = .5*(state[,1]+bskt_typeQ[policy_k_guess]))#
# DP_list$value_fn <- tmp#
#
solC <- value_iteration_fnC(DP_list, Bellman_operatorC, print_level=1, control_list)#
DP_list <- solC#
#
# ------------------------------ # #
# Check DP solution #
if(make_plot){#
	# Plot value function #
	sel		<- DP_list$state[,3] == 1 & DP_list$state[,4] == 0#
	scatterplot3d(DP_list$state[sel,1], DP_list$state[sel,2], DP_list$value_fn[sel], xlab = "I", ylab="y", zlab="value", #
				main="Value funciton", angle = 60)#
#
	# 2D value function along I#
	ggtmp <- data.frame(state, v=DP_list$value_fn)#
	quartz()#
	print(ggplot(ggtmp, aes(I, v, col=factor(Inc), linetype = factor(Rc)) ) + geom_point() + geom_line() + #
			facet_wrap(~ y) + #
			labs(title = "Value function in I\n facet by y")#
	)#
	# Plot policy function ccp#
	tmp <- Bellman_operatorC(DP_list, control_list)#
	tmp1 <- data.frame(state, tmp$ccp)#
	ggtmp <- melt(tmp1, id.var=c("I","y","Inc","Rc"))#
	names(ggtmp)[5] <- "policy"#
	quartz()#
	print( ggplot(ggtmp, aes(I, value, col=factor(Inc), linetype = factor(Rc) )) + geom_point() + geom_line() + #
			facet_grid(y ~ policy, labeller = "label_both") + #
			labs(y="Probability", title = "Policy function k(CCP) " )#
	)#
	# Plot policy function c#
	tmp 			<- DP_list$policy$c#
	dimnames(tmp) 	<- list(1:nrow(state), 1:K)#
	ggtmp 			<- melt(tmp)#
	names(ggtmp) 	<- c("state_index","k","c")#
	ggtmp$I			<- state[ggtmp$state_index, 1]#
	ggtmp$y			<- state[ggtmp$state_index, 2]#
	ggtmp$Inc		<- state[ggtmp$state_index, 3]#
	ggtmp$Rc		<- state[ggtmp$state_index, 4]#
	ggtmp$Q			<- bskt_typeQ[ggtmp$k]#
#
	quartz()#
	print(ggplot(ggtmp, aes(I, c, col=factor(Inc), linetype = factor(Rc), alpha=.3 )) + geom_point() + geom_line() + #
			facet_grid(k ~ y, labeller = "label_both") + #
			geom_abline(aes(intercept = Q, slope = 1), linetype=2) + #
			labs(title = paste("Policy function c at y grid",sep=""))#
	)#
	# Shape of objective function along c#
	c_grid 		<- seq(.5, 4, .2)#
	plot_state 	<- 98:106#
	state[plot_state,]#
	choice_k 	<- 4#
	tmp_cstar	<- DP_list$policy$c[plot_state, choice_k]#
	tmp			<- cal_valuefn(DP_list, c_grid, state[plot_state,], choice_k, TRUE, tmp_cstar)#
	tmp1 		<- cal_flow(DP_list, c_grid, state[plot_state,], choice_k, tmp_cstar)#
	dimnames(tmp) <- list(s_index = plot_state, c = c(c_grid,""))#
	dimnames(tmp1) <- list(s_index = plot_state, c = c(c_grid,""))#
	ggtmp		<- melt(tmp)#
	sel 		<- is.na(ggtmp$c)#
	ggtmp[sel,"c"] <- tmp_cstar#
	ggtmp$max_pnt <- 0#
	ggtmp[sel,"max_pnt"] <- 1#
	ggtmp1		<- melt(tmp1)#
	sel 		<- is.na(ggtmp1$c)#
	ggtmp1[sel,"c"] <- tmp_cstar#
	ggtmp1$max_pnt <- 0#
	ggtmp1[sel,"max_pnt"] <- 1	#
	ggtmp 		<- data.frame(rbind(ggtmp, ggtmp1), v=rep(c("value","flow"), each=nrow(ggtmp1)) )#
	ggtmp$I		<- state[ggtmp$s_index, 1]#
	ggtmp$lny	<- state[ggtmp$s_index, 2]#
	ggtmp$Inc	<- state[ggtmp$s_index, 3]#
	ggtmp$Rc	<- state[ggtmp$s_index, 4]#
#
	quartz()#
	print(ggplot(ggtmp, aes(c, value, linetype = v, shape = v)) + geom_point(aes(col=factor(max_pnt))) + #
				geom_line() + #
				facet_wrap(I ~ lny) + #
				scale_color_manual(values=c("black","red")) + #
				guides(color=FALSE) + #
				labs(title = paste("Value function curve at Q=",#
									round(bskt_typeQ[choice_k],2), "\n(facet by I,y)", sep=""))#
	)#
}
##################
# Simulate data ##
##################
init_state 	<- state[280,]	# Initial state#
TT			<- 300				# The length of simulating time series#
#
# No randomness in the consumption function #
set.seed(666) #
my_data <- simulate_seq1_fnC(init_state, TT, draw_all=TRUE, lny_seq=rep(NA,TT), Inc_seq = rep(NA, TT), #
 							Rc_seq=rep(NA, TT), k_seq = rep(NA, TT), DP_list, control_list)#
# Plot the simulation#
if(make_plot){#
	ggtmp <- my_data[[1]]#
	ggtmp$Q <- bskt_typeQ[ggtmp$k]#
	ggtmp$c_inventory <- with(ggtmp, c/(I+Q))#
	ggtmp1 <- melt(data.frame(ggtmp[,c("t","I","lny", "Inc", "k","c_inventory")]), id="t") #
	quartz()#
	ggplot(ggtmp1,aes(t, value)) + geom_point() + geom_line() + #
			facet_grid(variable ~ ., scales="free_y") + #
			labs(title = "Simulated sequence")#
}
param
###################
# Identification # #
###################
tmp 	<- Bellman_operatorC(DP_list, control_list)#
ccp_base<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])#
#
sel_param 	<- "lambda"		# The parameter name that is changed#
delta 		<- -.5		# The change value#
param1		<- param#
param1[sel_param] <- param[sel_param] + delta#
DP_list1	<- DP_list #
DP_list1$param <- param1#
DP_list1 	<- value_iteration_fnC(DP_list1, Bellman_operatorC, print_level=1, control_list)#
tmp			<- Bellman_operatorC(DP_list1, control_list)#
ccp1		<- data.frame(state, k1=tmp$ccp[,1], k2=tmp$ccp[,2], k3=tmp$ccp[,3], k4=tmp$ccp[,4])#
#
# Plot the CCP functions along states given the two sets of parameters#
ggtmp 		<- rbind(data.frame(ccp_base, Parameter = "Baseline"), data.frame(ccp1, Parameter = "Experiment"))#
ggtmp		<- melt(ggtmp, id.var=c("Parameter","I","y","Inc","Rc"))#
names(ggtmp)<- c("Parameter","I","y","Inc","Rc","policy","Probability")#
selRc		<- 0#
if(make_plot){#
	for(i in 1:n_Inc){#
	quartz()#
	print(ggplot(subset(ggtmp, Rc == selRc & Inc==i), aes(I, Probability, col=Parameter)) + geom_point() + geom_line() + #
		facet_grid(y  ~ policy, labeller = "label_both") + #
		labs( title = paste("CCP over Inc=", i, "\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
					"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )#
	)#
	}#
}#
#
# Plot the value function from two sets of parameters. #
ggtmp <- rbind(data.frame(state, V = DP_list$value, Parameter = "Baseline"), #
			   data.frame(state, V = DP_list1$value, Parameter = "Experiment"))#
selRc		<- 0#
if (make_plot){#
	quartz()#
	ggplot(subset(ggtmp, Rc==selRc), aes(I, V, col=Parameter)) + geom_point() + geom_line() + #
			facet_grid(Inc~y, labeller = "label_both") + #
			labs( title = paste("Value function over states\n Baseline: ", paste(names(param), param, collapse=",", sep="="), #
						"\n Experiment: ", paste(names(param1), param1, collapse=",", sep="="), sep="") )#
}
15/12
15/12*5
10.5*12/15
10.5*5/12
olrp <- function(beta, A,B,Q, R, W=NULL){#
	m 	<- max(dim(A))#
	rb	<- nrow(B)#
	cb	<- ncol(B)#
	if(is.null(W)) {W = matrix(0, m, cb) }#
	if(min(abs(eigen(R)$values)) > 1e-5){#
		stop("eigen value error");#
	}else{#
		p0 <-  - .01*diag(m)#
		dd <- 1#
		it <- 1#
		maxit <- 1000#
		while (dd>1e-6 & it<= maxit){#
			f0 	= solve(R+ beta * t(B) %*%p0 %*%B) %*% (beta* t(B)%*%p0%*%A + t(W))#
			p1	= beta*t(A) %*% p0 %*%A + Q - (beta * t(A) %*% p0 %*% B+ W) %*% f0#
			f1 	= solve(R + beta* t(B) %*% p1 %*% B) %*% (beta* t(B)%*%p1%*%A + t(W))#
			dd	= max(abs(f1 - f0));#
			it = it +1#
			p0 = p1#
		}#
	}#
	return(list(f = f1, p = p0))#
}#
#
lambda_w2 	= -.5;#
lambda_w1	= 3;#
lambda_c2 	= -1;#
lambda_c1	= 5;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= 2; #
tau2 		= -.1;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3)#
R1 	= matrix(c(tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2, 0, 0, lambda_c2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1+tau1*k, lambda_c1 - tau1), nrow=1)#
#
olrp(beta, A, B, R2, Q2, W)
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)
W
olrp(beta, A, B, R2, Q2, W)
olrp <- function(beta, A,B,Q, R, W=NULL){#
	m 	<- max(dim(A))#
	rb	<- nrow(B)#
	cb	<- ncol(B)#
	if(is.null(W)) {W = matrix(0, m, cb) }#
# 	if(min(abs(eigen(R)$values)) > 1e-5){#
# 		stop("eigen value error");#
# 	}else{#
		p0 <-  - .01*diag(m)#
		dd <- 1#
		it <- 1#
		maxit <- 1000#
		while (dd>1e-6 & it<= maxit){#
			f0 	= solve(R+ beta * t(B) %*%p0 %*%B) %*% (beta* t(B)%*%p0%*%A + t(W))#
			p1	= beta*t(A) %*% p0 %*%A + Q - (beta * t(A) %*% p0 %*% B+ W) %*% f0#
			f1 	= solve(R + beta* t(B) %*% p1 %*% B) %*% (beta* t(B)%*%p1%*%A + t(W))#
			dd	= max(abs(f1 - f0));#
			it = it +1#
			p0 = p1#
		}#
# 	}#
	return(list(f = f1, p = p0))#
}
olrp(beta, A, B, R2, Q2, W)
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
olrp(beta, A, B, R2, Q2, W)
sol <- olrp(beta, A, B, R2, Q2, W)#
round(sol$f, 3); round(sol$p, 3)
dim(A)
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)
mu = c(0, 2, 1);#
Sigma = matrix(0, 3, 3); Sigma[2,2] = 1; Sigma[3,3] = .5;
mu
Sigma
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)
S
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )
G
?tr
trace(diag(3))
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* t(mu) %*% S + beta * sum(diag(P %*% Sigma)) )/(1-beta)
d
S
S 	<- matrix(S, nrow = 1)
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* t(mu) %*% S + beta * sum(diag(P %*% Sigma)) )/(1-beta)
mu
S
mu %*% S
S %*% mu
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)
d
P
round(P, 3) #
round(S, 3)#
d
lambda_w2 	= -.5;#
lambda_w1	= 3;#
lambda_c2 	= -1;#
lambda_c1	= 5;#
lambda_o2 	= -.5;#
lambda_o1	= 3;#
tau1		= 2; #
tau2 		= -.1;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
mu = c(0, 2, 1);#
Sigma = matrix(0, 3, 3); Sigma[2,2] = 1; Sigma[3,3] = .5; #
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d
lambda_w2 	= -.5;#
lambda_w1	= 3;#
lambda_c2 	= -1;#
lambda_c1	= 5;#
lambda_o2 	= -.5;#
lambda_o1	= 3;#
tau1		= 2; #
tau2 		= 0;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
mu = c(0, 2, 1);#
Sigma = matrix(0, 3, 3); Sigma[2,2] = 1; Sigma[3,3] = .5; #
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d
lambda_w2 	= -.5;#
lambda_w1	= 3;#
lambda_c2 	= -1;#
lambda_c1	= 5;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= 2; #
tau2 		= 0;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
mu = c(0, 2, 1);#
Sigma = matrix(0, 3, 3); Sigma[2,2] = 1; Sigma[3,3] = .5; #
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d
F
round(F, 3)
lambda_w2 	= -.5;#
lambda_w1	= 3;#
lambda_c2 	= -1;#
lambda_c1	= 5;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= 2; #
tau2 		= -.2;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
mu = c(0, 2, 1);#
Sigma = matrix(0, 3, 3); Sigma[2,2] = 1; Sigma[3,3] = .5; #
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d
olrp <- function(beta, A,B,Q, R, W=NULL){#
	m 	<- max(dim(A))#
	rb	<- nrow(B)#
	cb	<- ncol(B)#
	if(is.null(W)) {W = matrix(0, m, cb) }#
# 	if(min(abs(eigen(R)$values)) > 1e-5){#
# 		stop("eigen value error");#
# 	}else{#
		p0 <-  - .01*diag(m)#
		dd <- 1#
		it <- 1#
		maxit <- 1000#
		while (dd>1e-6 & it<= maxit){#
			f0 	= solve(R+ beta * t(B) %*%p0 %*%B) %*% (beta* t(B)%*%p0%*%A + t(W))#
			p1	= beta*t(A) %*% p0 %*%A + Q - (beta * t(A) %*% p0 %*% B+ W) %*% f0#
			f1 	= solve(R + beta* t(B) %*% p1 %*% B) %*% (beta* t(B)%*%p1%*%A + t(W))#
			dd	= max(abs(f1 - f0));#
			it = it +1#
			p0 = p1#
		}#
# 	}#
	return(list(f = f1, p = p0))#
}#
#
lambda_w2 	= -.5;#
lambda_w1	= 3;#
lambda_c2 	= -1;#
lambda_c1	= 5;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= 2; #
tau2 		= 0;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
mu = c(0, 2, 1);#
Sigma = matrix(0, 3, 3); Sigma[2,2] = 1; Sigma[3,3] = .5; #
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d
F
round(F,3)
round(G,3)
olrp <- function(beta, A,B,Q, R, W=NULL){#
	m 	<- max(dim(A))#
	rb	<- nrow(B)#
	cb	<- ncol(B)#
	if(is.null(W)) {W = matrix(0, m, cb) }#
# 	if(min(abs(eigen(R)$values)) > 1e-5){#
# 		stop("eigen value error");#
# 	}else{#
		p0 <-  - .01*diag(m)#
		dd <- 1#
		it <- 1#
		maxit <- 1000#
		while (dd>1e-6 & it<= maxit){#
			f0 	= solve(R+ beta * t(B) %*%p0 %*%B) %*% (beta* t(B)%*%p0%*%A + t(W))#
			p1	= beta*t(A) %*% p0 %*%A + Q - (beta * t(A) %*% p0 %*% B+ W) %*% f0#
			f1 	= solve(R + beta* t(B) %*% p1 %*% B) %*% (beta* t(B)%*%p1%*%A + t(W))#
			dd	= max(abs(f1 - f0));#
			it = it +1#
			p0 = p1#
		}#
# 	}#
	return(list(f = f1, p = p0))#
}#
#
lambda_w2 	= -.5;#
lambda_w1	= 3;#
lambda_c2 	= -1;#
lambda_c1	= 5;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= 2; #
tau2 		= -.5;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
mu = c(0, 2, 1);#
Sigma = matrix(0, 3, 3); Sigma[2,2] = 1; Sigma[3,3] = .5; #
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d
F
G
myfn <- function(x, lambda1, lambda2){#
	lambda2*x^2+ lambda1*x#
}
x <- seq(1,10, by=.1)
plot(x, myfn(x, .5, -.5))
plot(x, myfn(x, -.5, .5))
plot(x, myfn(x, -.8, .5))
plot(x, myfn(x, -1, .5))
plot(x, myfn(x, -2, .5))
plot(x, myfn(x, -3, .5))
plot(x, myfn(x, .1, .5))
plot(x, myfn(x, .1, .05))
plot(x, myfn(x, .1, .02))
olrp <- function(beta, A,B,Q, R, W=NULL){#
	m 	<- max(dim(A))#
	rb	<- nrow(B)#
	cb	<- ncol(B)#
	if(is.null(W)) {W = matrix(0, m, cb) }#
# 	if(min(abs(eigen(R)$values)) > 1e-5){#
# 		stop("eigen value error");#
# 	}else{#
		p0 <-  - .01*diag(m)#
		dd <- 1#
		it <- 1#
		maxit <- 1000#
		while (dd>1e-6 & it<= maxit){#
			f0 	= solve(R+ beta * t(B) %*%p0 %*%B) %*% (beta* t(B)%*%p0%*%A + t(W))#
			p1	= beta*t(A) %*% p0 %*%A + Q - (beta * t(A) %*% p0 %*% B+ W) %*% f0#
			f1 	= solve(R + beta* t(B) %*% p1 %*% B) %*% (beta* t(B)%*%p1%*%A + t(W))#
			dd	= max(abs(f1 - f0));#
			it = it +1#
			p0 = p1#
		}#
# 	}#
	return(list(f = f1, p = p0))#
}#
#
myfn <- function(x, lambda1, lambda2){#
	lambda2*x^2+ lambda1*x#
}#
#
lambda_w2 	= -.5;#
lambda_w1	= 6;#
lambda_c2 	= -.25;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .02;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
mu = c(0, 1, 1);#
Sigma = matrix(0, 3, 3); Sigma[2,2] = 1; Sigma[3,3] = .5; #
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d
lambda_w2 	= -.5;#
lambda_w1	= 6;#
lambda_c2 	= -.25;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
mu = c(0, 1, 1);#
Sigma = matrix(0, 3, 3); Sigma[2,2] = 1; Sigma[3,3] = .5; #
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d
lmu			= c(-Inf, 0, 0);#
lsigma		= c(0, .5, .2);#
mu 			= exp(mu + .5*lsigma^2)
mu
exp(lsigma^2) -1
(exp(lsigma^2) -1)*exp(2*lmu + lsigma^2)
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));
Sigma
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, ncol(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])
init_state
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])
zdraw
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}
state
ustar
zdraw
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, 0, 0);#
lsigma		= c(0, .2, .3);#
mu 			= exp(mu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}
state
ustar
ubar
tmp		<- cbind(t = 1:TT, state, ustar)
head(tmp)
# Plot the state#
tmp		<- cbind(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")
library(reshape2)
library(ggplot2)
# Plot the state#
tmp		<- cbind(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")
head(ggtmp)
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")
head(ggtmp)
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")
head(tmp)
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))
head(ggtmp)
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(. ~ variable)
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, 0, 1);#
lsigma		= c(0, .2, .3);#
mu 			= exp(mu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, 0, 0);#
lsigma		= c(0, .2, .3);#
mu 			= exp(mu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, 0, 0);#
lsigma		= c(0, .2, .3);#
mu 			= exp(mu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d
mu
lmu			= c(-Inf, 0, 0);#
lsigma		= c(0, .2, .3);#
mu 			= exp(mu + .5*lsigma^2)
mu
lmu			= c(-Inf, 0, 0);#
lsigma		= c(0, .2, .3);#
mu 			= exp(lmu + .5*lsigma^2)
mu
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, 0, .1);#
lsigma		= c(0, .2, .3);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, 0, .5);#
lsigma		= c(0, .2, .3);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
mu
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, 0, .5);#
lsigma		= c(0, .2, .4);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
mu
Sigma
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, 0, 2);#
lsigma		= c(0, .2, .4);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));
mu
Sigma
lsigma		= c(0, .2, .3);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));
Sigma
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
mu
sigma
Sigma
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, 0, 1.5);#
lsigma		= c(0, .2, .3);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
eps_inc
zdraw
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, 0, 1.5);#
lsigma		= c(0, .2, .3);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
state
F
G
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, 0, 1);#
lsigma		= c(0, .2, .3);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, 0, 1);#
lsigma		= c(0, .2, 1);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));
mu
Sigma
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, 0, 1);#
lsigma		= c(0, .2, .5);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));
mu
Sigma
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, 0, 1);#
lsigma		= c(0, .2, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));
mu
Sigma
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1);#
lsigma		= c(0, .2, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));
Sigma
mu
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 2;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 4;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3.5;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3.1;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3.1;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3.1;#
tau1		= .1; #
tau2 		= .05;#
k 			= .2;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3.1;#
tau1		= .1; #
tau2 		= .05;#
k 			= .65;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3.2;#
tau1		= .1; #
tau2 		= .05;#
k 			= .65;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.2;#
lambda_w1	= 7;#
lambda_c2 	= -.2;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .65;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.1;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .5;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .6);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
mu
Sigma
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .4);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
zdraw
eps_inc
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 1.5;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .3; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .4);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 1.5;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .5; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .4);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 1.5;#
tau1		= .1; #
tau2 		= .05;#
k 			= .7;#
rho 		= .5; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .4);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 1.5;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 1.2);#
lsigma		= c(0, .3, .4);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 1.5;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .4);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 2;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .4);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 4;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, .5, 1.1);#
lsigma		= c(0, .3, .4);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 2.5;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, .5, 1);#
lsigma		= c(0, .3, .4);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))
mu
Sigma
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
state
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 2.5;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, .5, 1);#
lsigma		= c(0, .3, .3);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. )
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 2.5;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, .5, 1);#
lsigma		= c(0, .1, .3);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- min(ubar[i,1], ymax)#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- min(ubar[i,2], cmax)#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
mu
Sigma
zdraw
ymax
ubar[i,]
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_o1
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 2;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, .5, 1);#
lsigma		= c(0, .1, .3);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 2;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, .3, 1.1);#
lsigma		= c(0, .1, .3);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, .3, 1.1);#
lsigma		= c(0, .1, .3);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, .5, 1.5);#
lsigma		= c(0, .1, .3);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.05;#
lambda_c1	= 2;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, .5, 1.5);#
lsigma		= c(0, .1, .3);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.01;#
lambda_c1	= 2;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, .5, 1.5);#
lsigma		= c(0, .1, .3);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.01;#
lambda_c1	= 2;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .7; #
beta= .95;#
lmu			= c(-Inf, .5, 1.5);#
lsigma		= c(0, .1, 1);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.01;#
lambda_c1	= 2;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 2);#
lsigma		= c(0, .1, .5);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 3;#
lambda_c2 	= -.01;#
lambda_c1	= 2;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 2);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.2;#
lambda_w1	= 4;#
lambda_c2 	= -.02;#
lambda_c1	= 4;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 2);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))
lambda_w2 	= -.2;#
lambda_w1	= 4;#
lambda_c2 	= -.2;#
lambda_c1	= 4;#
lambda_o2 	= 0;#
lambda_o1	= 3;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 2);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.5;#
lambda_w1	= 4;#
lambda_c2 	= -.2;#
lambda_c1	= 4;#
lambda_o2 	= 0;#
lambda_o1	= 4;#
tau1		= .1; #
tau2 		= .05;#
k 			= .6;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 2);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
myfn <- function(x, lambda1, lambda2){#
	lambda2*x^2+ lambda1*x#
}#
#
lambda_w2 	= -.5;#
lambda_w1	= 0;#
lambda_c2 	= -.2;#
lambda_c1	= 0;#
lambda_o2 	= 0;#
lambda_o1	= 4;#
tau1		= 0; #
tau2 		= .05;#
k 			= .6;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 2);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))
olrp <- function(beta, A,B,Q, R, W=NULL){#
	m 	<- max(dim(A))#
	rb	<- nrow(B)#
	cb	<- ncol(B)#
	if(is.null(W)) {W = matrix(0, m, cb) }#
# 	if(min(abs(eigen(R)$values)) > 1e-5){#
# 		stop("eigen value error");#
# 	}else{#
		p0 <-  - .01*diag(m)#
		dd <- 1#
		it <- 1#
		maxit <- 1000#
		while (dd>1e-6 & it<= maxit){#
			f0 	= solve(R+ beta * t(B) %*%p0 %*%B) %*% (beta* t(B)%*%p0%*%A + t(W))#
			p1	= beta*t(A) %*% p0 %*%A + Q - (beta * t(A) %*% p0 %*% B+ W) %*% f0#
			f1 	= solve(R + beta* t(B) %*% p1 %*% B) %*% (beta* t(B)%*%p1%*%A + t(W))#
			dd	= max(abs(f1 - f0));#
			it = it +1#
			p0 = p1#
		}#
# 	}#
	return(list(f = f1, p = p0))#
}#
#
myfn <- function(x, lambda1, lambda2){#
	lambda2*x^2+ lambda1*x#
}#
#
lambda_w2 	= -.5;#
lambda_w1	= 4;#
lambda_c2 	= -.2;#
lambda_c1	= 6;#
lambda_o2 	= 0;#
lambda_o1	= 4;#
tau1		= 0; #
tau2 		= .05;#
k 			= .6;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 2);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d
lambda_w2 	= -.1;#
lambda_w1	= 5;#
lambda_c2 	= -.2;#
lambda_c1	= 6;#
lambda_o2 	= 0;#
lambda_o1	= 4;#
tau1		= 0; #
tau2 		= .05;#
k 			= .5;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 1);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 5;#
lambda_c2 	= -.2;#
lambda_c1	= 6;#
lambda_o2 	= 0;#
lambda_o1	= 4;#
tau1		= 0; #
tau2 		= .1;#
k 			= .5;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 1);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 5;#
lambda_c2 	= -.2;#
lambda_c1	= 6;#
lambda_o2 	= 0;#
lambda_o1	= 4;#
tau1		= 0; #
tau2 		= .1;#
k 			= .5;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 1.2);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 5;#
lambda_c2 	= -.2;#
lambda_c1	= 6;#
lambda_o2 	= 0;#
lambda_o1	= 4;#
tau1		= 0; #
tau2 		= 0;#
k 			= .5;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 1.2);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 5;#
lambda_c2 	= -.2;#
lambda_c1	= 6;#
lambda_o2 	= 0;#
lambda_o1	= 5;#
tau1		= 0; #
tau2 		= 0;#
k 			= .5;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 1.2);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
F
G
lambda_w2 	= -.1;#
lambda_w1	= 5;#
lambda_c2 	= -.2;#
lambda_c1	= 5;#
lambda_o2 	= 0;#
lambda_o1	= 5;#
tau1		= 0; #
tau2 		= 0;#
k 			= .5;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 1.2);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 6;#
lambda_c2 	= -.2;#
lambda_c1	= 5;#
lambda_o2 	= 0;#
lambda_o1	= 4.5;#
tau1		= 0; #
tau2 		= 0;#
k 			= .5;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 1.2);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 6;#
lambda_c2 	= -.2;#
lambda_c1	= 6;#
lambda_o2 	= 0;#
lambda_o1	= 4.5;#
tau1		= 0; #
tau2 		= 0;#
k 			= .5;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 1.2);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 6;#
lambda_c2 	= -.2;#
lambda_c1	= 3;#
lambda_o2 	= 0;#
lambda_o1	= 4.5;#
tau1		= 0; #
tau2 		= 0;#
k 			= .5;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 1.2);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 4.5;#
tau1		= 0; #
tau2 		= 0;#
k 			= .5;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 1.2);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
lambda_w2 	= -.1;#
lambda_w1	= 6;#
lambda_c2 	= -.1;#
lambda_c1	= 1.5;#
lambda_o2 	= 0;#
lambda_o1	= 4.5;#
tau1		= 1; #
tau2 		= 0;#
k 			= .5;#
rho 		= .6; #
beta= .95;#
lmu			= c(-Inf, .5, 1.2);#
lsigma		= c(0, .1, .2);#
mu 			= exp(lmu + .5*lsigma^2)#
Sigma 		= diag((exp(lsigma^2) -1)*exp(2*lmu + lsigma^2));#
#
# Plot the utilify functions#
x 			<- seq(1, 10, by=.1)#
par(mfrow= c(2,2))#
plot(x, myfn(x, lambda_w1, lambda_w2))#
plot(x, myfn(x, lambda_c1, lambda_c2))#
plot(x, myfn(x, lambda_o1, lambda_o2))#
plot(x, myfn(x, tau1, tau2))#
#
A 	= matrix(c(1, 0, 0, 0, 1, 1, 0, 0, rho), 3,3,byrow=T)#
B	= matrix(c(k, -1, -1, 0, 0, 0), 3, 2, byrow=T)#
#
R2	= matrix(0, 3,3); R2[1,1] <- -tau2; R2[3,3] <- lambda_o2;#
R1 	= matrix(c(-tau1, 0, lambda_o1), nrow=1)#
Q2	= matrix(c(lambda_w2 + lambda_o2 - tau2*k^2, tau2*k, tau2*k, lambda_c2-tau2), 2,2, byrow=T)#
Q1	= matrix(c(lambda_w1-lambda_o1-tau1*k, lambda_c1 + tau1), nrow=1)#
W	= matrix(c(-tau2*k, tau2, 0, 0, -lambda_o2, 0), 3, 2, byrow=T)#
#
sol <- olrp(beta, A, B, R2, Q2, W)#
F 	<- sol$f#
P 	<- sol$p#
S 	<- (R1+ Q1 %*% F + 2*beta*t(mu) %*% t(P) %*% (A+ B%*% F)) %*% solve(diag(3) - beta*A - beta*B %*% F)#
S 	<- matrix(S, nrow = 1)#
G	<- -.5 * solve(Q2 + beta*t(B) %*% P %*% B) %*% (2*beta*t(B) %*% P %*% mu + beta*t(B) %*% t(S) + t(Q1) )#
d 	<- (.5*(Q1 + beta* S %*% B + 2*beta*t(mu) %*% P %*% B) %*% G + beta* S %*% mu + beta * sum(diag(P %*% Sigma)) )/(1-beta)#
round(P, 3) #
round(S, 3)#
d#
#
# Simulate the data #
TT 			<- 100#
init_state	<- c(I=3, B= 5, Inc=1)#
state 		<- matrix(NA, TT, length(init_state))#
state[1,]	<- init_state#
ubar		<- matrix(NA, TT, 2)#
ustar		<- matrix(NA, TT, 2)#
zdraw		<- rlnorm(TT, lmu[2], lsigma[2])#
eps_inc		<- rlnorm(TT, lmu[3], lsigma[3])#
for(i in 1:TT){#
	ubar[i,] 	<- F %*% state[i,] + G#
	ymax 		<- state[i,2] + state[i,3] - zdraw[i]#
	ustar[i,1]	<- max(0, min(ubar[i,1], ymax))#
	cmax 		<- state[i,1] + k*ustar[i,1]#
	ustar[i,2] 	<- max(0,min(ubar[i,2], cmax))#
	if(i< TT){#
		state[(i+1), 1] <- state[i,1] + k*ustar[i,1] - ustar[i,2]#
		state[(i+1), 2] <- state[i,2] + state[i,3] - zdraw[i] - ustar[i,1]#
		state[(i+1), 3] <- rho * state[i,3] + eps_inc[i]#
	}#
}#
#
# Plot the state#
tmp		<- data.frame(t = 1:TT, state, ustar)#
names(tmp) <- c("t","I","B","Inc","y","c")#
ggtmp	<- melt(tmp, id.var="t")#
ggtmp$sol	<- "realized"#
tmp		<- melt(data.frame(t=1:TT, y=ubar[,1], c=ubar[,2]), id.var="t")#
ggtmp	<- rbind(ggtmp, cbind(tmp, sol="star"))#
ggplot(ggtmp, aes(t, value, col=sol)) + geom_point() + geom_line() + #
		facet_grid(variable ~. , scales="free_y")
load("/Users/chaoqunchen/Desktop/analysis_results.rdata")
ls()
library(reshape2)#
library(ggplot2)#
library(Rcpp)#
library(RcppArmadillo)#
library(maxLik)#
library(evd)#
#
setwd("~/Documents/Research/Store switching/Exercise/Multiple_discrete_continuous_model")#
model_name <- "MDCEV_a1b2"#
#
sourceCpp(paste(model_name, ".cpp", sep=""))#
source("0_Allocation_function.R")
library(reshape2)#
library(ggplot2)#
library(Rcpp)#
library(RcppArmadillo)#
library(maxLik)#
library(evd)#
#
setwd("~/Documents/Research/Store switching/Exercise/Multiple_discrete_continuous_model")#
model_name <- "MDCEV_a1b2"#
#
sourceCpp(paste(model_name, ".cpp", sep=""))#
source("0_Allocation_function.R")
library(reshape2)#
library(ggplot2)#
library(Rcpp)#
library(RcppArmadillo)#
library(maxLik)#
library(evd)#
#
setwd("~/Documents/Research/Store switching/Exercise/Multiple_discrete_continuous_model")#
model_name <- "MDCEV_a1b2"#
#
sourceCpp(paste(model_name, ".cpp", sep=""))#
source("0_Allocation_function.R")
# Set paraemters #
R		<- 3 		# Number of alternatives#
Ra		<- R		# Number of alternatives + number of outside options#
exp_outside <- quant_outside <- FALSE#
beta0 	<- c(0, -1, -1)#
beta	<- c(.5, -.7)#
gamma0 	<- gamma	<- c(1, 1, 1)#
sigma 	<- 1#
if(substr(model_name,7,8)=="a2"){#
	Ra 	<- Ra + 1#
	exp_outside <- TRUE#
	gamma	<- c(gamma, 1)#
}#
if(substr(model_name,9,10)=="b2"){#
	Ra 	<- Ra + 1#
	quant_outside <- TRUE#
	gamma <- c(gamma, 1)#
}#
qz_cons	<- 10#
psi_R1	<- 1#
psi_R2	<- .01#
#
# Simulate data #
set.seed(666666)#
nx 		<- length(beta)#
N 		<- 500		# Number of observations#
X_arr 	<- array(rnorm(N*R*nx), c(R, N, nx))#
X_list  <- lapply(1:R, function(i) X_arr[i,,])#
price 	<- matrix(runif(N*R, 2, 4), N, R)#
Q		<- runif(N, 1, 20)#
y		<- rowSums(price) * Q/R #
#
par(mfrow=c(3,1))#
hist(y, breaks=100)#
hist(Q, breaks=100)#
hist(as.vector(price), breaks=100)#
#
eps_draw<- matrix(rgumbel(N*R), N, R)#
xbeta	<- do.call(cbind, lapply(1:R, function(i) X_list[[i]] %*% beta + beta0[i]))#
psi		<- exp(xbeta + eps_draw)#
if(substr(model_name,7,8)=="a2"){#
	psi	<- cbind(psi, psi_R1)#
}#
if(substr(model_name,9,10)=="b2"){#
	psi	<- cbind(psi, psi_R2)#
}#
e_mat <- matrix(NA, N, Ra)#
for(i in 1:N){#
	tmp	<- Allocation_fn(y = y[i], psi = psi[i,], gamma, Q = Q[i], price = price[i,], R, Ra, qz_cons, exp_outside, quant_outside)#
	e_mat[i,] <- tmp$e#
}#
eps <- 1e-4#
eR 	<- e_mat[,1:R]#
eR[eR<=eps] <- 0#
mean(eR==0)#
#
sel	<- apply(eR, 1, function(x) !all(x==0))#
eR 	<- eR[sel,]#
Q	<- Q[sel]#
y	<- y[sel]#
price <- price[sel,]#
X_list <- lapply(X_list, function(x) x[sel,])#
e1_index <- apply(eR, 1, function(x) which(x== min(x[x>0])))
# Estimation #
if(substr(model_name,7,8)=="a1"){#
	if(substr(model_name,9,10)=="b2"){#
		MDCEV_wrapper <- function(param) {#
			MDCEV_LogLike_fnC(param, nx, c_q=qz_cons, Q=Q, e=eR, e1_index = e1_index, #
			p=price, X_list = X_list)#
		}#
	}else{#
		MDCEV_wrapper <- function(param){#
			MDCEV_LogLike_fnC(param, nx, e1_index = e1_index, e=eR, p=price, X_list = X_list)#
		}#
	}#
}else{#
	if(substr(model_name,9,10)=="b2"){#
		MDCEV_wrapper <- function(param) {#
			MDCEV_LogLike_fnC(param, nx, c_q=qz_cons, y = y, Q=Q, e=eR, p=price, X_list = X_list)#
		}#
	}else{#
		MDCEV_wrapper <- function(param){#
			MDCEV_LogLike_fnC(param, nx, y=y, e=eR, p=price, X_list = X_list)#
		}#
	}#
}#
#
# Estimation with multiple initial values. #
# theta_init	<- list(c(beta, beta0[-1]), #
# 					c(1, -1, 2, -1.5), 		# Close to the true values#
# 					c(-3, -3, 4, -1)  #
# 					)#
# Estimation with multiple initial values (full set of parameters)#
theta_init0	<- c(beta, beta0, gamma0, log(psi_R1), log(psi_R2), log(sigma))#
theta_init2	<- theta_init1 <- theta_init0#
theta_init1[1:(nx+R)] <- theta_init0[1:(nx+R)] + rnorm(nx+R)#
theta_init2[1:(nx+R)] <- rep(5, nx+R)#
theta_init 	<- list(theta_init0, theta_init1, theta_init2)#
system.time(tmp <- MDCEV_wrapper(theta_init[[1]]))
tmp_sol <- vector("list", length(theta_init))#
pct <- proc.time()#
for(i in 1:length(theta_init)){#
	names(theta_init[[i]]) <- c(paste("beta_",1:nx, sep=""), paste("beta0_",1:R,sep=""), paste("gamma",1:R, sep=""),#
								"ln_psi1", "ln_psi2", "ln_sigma")	#
	tmp_sol[[i]]	<- maxLik(MDCEV_wrapper, start=theta_init[[i]], method="BFGS")#
}#
sel 	<- which.max(sapply(tmp_sol, function(x) ifelse(is.null(x$maximum), NA, x$maximum)))#
sol		<- tmp_sol[[sel]]#
lapply(tmp_sol, summary)
# Fix scale parameter and psi for outside options and satiation parameters#
myfix <- (length(theta_init0) - (2+R)):length(theta_init0)#
tmp_sol <- vector("list", length(theta_init))#
for(i in 1:length(theta_init)){#
	names(theta_init[[i]]) <- c(paste("beta_",1:nx, sep=""), paste("beta0_",1:R,sep=""), paste("gamma",1:R, sep=""),#
								"ln_psi1", "ln_psi2", "ln_sigma")	#
	tmp_sol[[i]]	<- maxLik(MDCEV_wrapper, start=theta_init[[i]], method="BFGS", fixed = myfix)#
}#
lapply(tmp_sol, summary)
# Fix scale parameter and psi for outside options, satiation parameters, and one beta intercept#
theta_init[[2]][(nx+1)] <- theta_init[[3]][(nx+1)] <- 0#
myfix <- c(nx+1, (length(theta_init0) - (2+R)):length(theta_init0))#
tmp_sol <- vector("list", length(theta_init))#
for(i in 1:length(theta_init)){#
	names(theta_init[[i]]) <- c(paste("beta_",1:nx, sep=""), paste("beta0_",1:R,sep=""), paste("gamma",1:R, sep=""),#
								"ln_psi1", "ln_psi2", "ln_sigma")	#
	tmp_sol[[i]]	<- maxLik(MDCEV_wrapper, start=theta_init[[i]], method="BFGS", fixed = myfix)#
}#
lapply(tmp_sol, summary)
sourceCpp(paste(model_name, ".cpp", sep=""))
# Fix scale parameter and psi for outside options, satiation parameters, and one beta intercept#
theta_init[[2]][(nx+1)] <- theta_init[[3]][(nx+1)] <- 0#
myfix <- c(nx+1, (length(theta_init0) - (2+R)):length(theta_init0))#
tmp_sol <- vector("list", length(theta_init))#
for(i in 1:length(theta_init)){#
	names(theta_init[[i]]) <- c(paste("beta_",1:nx, sep=""), paste("beta0_",1:R,sep=""), paste("gamma",1:R, sep=""),#
								"ln_psi1", "ln_psi2", "ln_sigma")	#
	tmp_sol[[i]]	<- maxLik(MDCEV_wrapper, start=theta_init[[i]], method="BFGS", fixed = myfix)#
}#
lapply(tmp_sol, summary)
beta
# Fix scale parameter and psi for outside options and satiation parameters#
myfix <- (length(theta_init0) - (2+R)):length(theta_init0)#
tmp_sol <- vector("list", length(theta_init))#
for(i in 1:length(theta_init)){#
	names(theta_init[[i]]) <- c(paste("beta_",1:nx, sep=""), paste("beta0_",1:R,sep=""), paste("gamma",1:R, sep=""),#
								"ln_psi1", "ln_psi2", "ln_sigma")	#
	tmp_sol[[i]]	<- maxLik(MDCEV_wrapper, start=theta_init[[i]], method="BFGS", fixed = myfix)#
}#
lapply(tmp_sol, summary)
